# **Feature design: M1.3 - CLI Project Initialization**

**Purpose**: Enable developers to bootstrap new Holt projects with `holt init`
**Scope**: Foundation for CLI experience - creates project scaffolding
**Estimated tokens**: ~5,000 tokens

Associated phase: **Heartbeat (Phase 1)**
Status: **Draft**

***Template purpose:*** *This document is a blueprint for a single, implementable milestone. Its purpose is to provide an unambiguous specification for a developer (human or AI) to build a feature that is consistent with Holt's architecture and guiding principles.*

## **1. The 'why': goal and success criteria**

### **1.1. Goal statement**

Enable developers to create a working Holt project structure with a single command, providing immediate scaffolding that demonstrates best practices and accelerates initial setup.

### **1.2. User story**

As a developer exploring Holt, I want to run `holt init` in my Git repository and immediately get a working project structure with example configuration so that I can understand how to organize my agents and start building without reading extensive documentation first.

### **1.3. Success criteria**

* A developer can run `holt init` in a Git repository root and receive a working `holt.yml` file with a documented example agent
* The command creates the `agents/example-agent/` directory with Dockerfile and script demonstrating the agent contract
* Running `holt init` in a directory that already has `holt.yml` fails with a clear error message (unless `--force` is used)
* Running `holt init` outside a Git repository root fails with a clear, actionable error message
* After successful initialization, the user receives a summary of created files and actionable next steps

**Validation questions:**
* ✅ Can each success criterion be automated as a test? Yes - all are testable
* ✅ Does each criterion represent user-visible value? Yes - creates immediate working structure
* ✅ Are the criteria specific enough to avoid ambiguity? Yes - specific files and behaviors defined

### **1.4. Non-goals**

* **NOT in scope**: Validating `holt.yml` syntax or semantic correctness (deferred to M1.4)
* **NOT in scope**: Creating or modifying `.gitignore` (we advise the user to do this)
* **NOT in scope**: Creating `README.md` or other documentation files
* **NOT in scope**: Building Docker images (we create Dockerfiles, building happens in M1.4)
* **NOT in scope**: Starting any services or containers (that's M1.4 - `holt up`)
* **NOT in scope**: Checking if Docker is installed
* **NOT in scope**: Validating Git repository is clean (future enhancement)
* **NOT in scope**: Supporting initialization in Git subdirectories (must be at root)

## **2. The 'what': component impact analysis**

**Critical validation questions for this entire section:**
* ✅ Have I explicitly considered EVERY component (Blackboard, Orchestrator, Pup, CLI)?
* ✅ For components marked "No changes" - am I absolutely certain this feature doesn't affect them?
* ✅ Do my changes maintain the contracts and interfaces defined in the design documents?
* ✅ Will this feature work correctly with both single-instance and scaled agents (controller-worker pattern)?

### **2.1. Blackboard changes**

**No changes** - This milestone creates static files, does not interact with Redis.

### **2.2. Orchestrator changes**

**No changes** - Orchestrator consumes `holt.yml` created by this command, but the orchestrator itself is not modified.

### **2.3. Agent pup changes**

**No changes** - The example agent created demonstrates the pup contract, but the pup implementation is Phase 2.

### **2.4. CLI changes**

* **New command: `holt init`**

  **Syntax:**
  ```bash
  holt init [--force]
  ```

  **Flags:**
  - `--force` (bool): Overwrite existing `holt.yml` and `agents/` directory if they exist

  **Behavior:**
  1. Verify execution context (Git repository root)
  2. Check for existing files
  3. Create project structure
  4. Write template files
  5. Display success message with next steps

  **Exit codes:**
  - `0`: Success - project initialized
  - `1`: Error - not in Git repository, not at Git root, or files exist without --force

* **Changes to user output:**

  Success message format:
  ```
  Successfully initialized Holt project!

  Created:
    ✓ holt.yml
    ✓ agents/example-agent/Dockerfile
    ✓ agents/example-agent/run.sh
    ✓ agents/example-agent/README.md

  Next steps:
    1. Add '.holt/' to your .gitignore file
    2. Customize holt.yml to add your own agents
    3. Run 'holt up' to start the Holt orchestrator

  For more information, visit: https://docs.holt.ai/getting-started
  ```

## **3. The 'how': implementation & testing plan**

### **3.1. Key design decisions & risks**

**Decision 1: CLI framework choice (Cobra)**

* **Rationale**: Use `github.com/spf13/cobra` as the CLI framework
* **Benefits**:
  - Industry standard (used by kubectl, docker CLI, hugo, GitHub CLI)
  - Excellent flag parsing and command structure
  - Automatic help generation
  - Easy to add new commands as we progress through milestones
  - Well-documented and actively maintained
* **Risk**: Adds external dependency. Mitigation: Cobra is stable, widely-used, and worth the trade-off vs building custom parser
* **Alternatives considered**:
  - urfave/cli (lighter but less feature-rich)
  - Custom parser (YAGNI violation)

**Decision 2: Require Git repository root**

* **Rationale**: `holt init` must be executed from the Git repository root, not a subdirectory
* **Benefits**:
  - Simple mental model: "one Holt instance per Git repo at the root"
  - Clear workspace semantics for agent mounting (workspace = Git root = ".")
  - Prevents path ambiguity in all future milestones
  - Aligns with "Git-centric workflow" architectural principle
  - Simplifies M1.4 workspace mounting (just mount current directory)
* **Risk**: Restricts flexibility for monorepo use cases. Mitigation: YAGNI for V1, can add `--workspace` flag in Phase 3+ if needed
* **Validation**:
  ```bash
  # Check Git repo exists
  git rev-parse --git-dir

  # Check we're at Git root
  git rev-parse --show-toplevel  # Compare with current directory
  ```

**Decision 3: Embedded templates vs external files**

* **Rationale**: Embed all templates in the binary using Go's `embed` directive
* **Benefits**:
  - Single binary distribution (no separate template files to manage)
  - Version coupling (templates always match binary version)
  - Simpler installation (just download binary)
* **Risk**: Template changes require recompilation. Mitigation: Acceptable for V1, templates are stable

**Decision 4: --force behavior (nuclear option)**

* **Rationale**: `--force` removes and recreates both `holt.yml` and `agents/` directory entirely
* **Benefits**:
  - Clear semantics: "start completely fresh"
  - Prevents partial state corruption
  - Simple implementation
* **Risk**: Could destroy user work in `agents/` if misused. Mitigation: Require explicit flag, show warning, document clearly

**Decision 5: Example agent complexity (mock greeter)**

* **Rationale**: Create a simple greeter agent that demonstrates the stdin/stdout contract without requiring LLM APIs
* **Benefits**:
  - Works out of the box (no API keys needed)
  - Educational - shows the contract clearly
  - Realistic enough to be useful as a template
* **Risk**: Might be too simple. Mitigation: Include comments explaining how to extend it

### **3.2. Implementation steps**

**Step 1: Set up CLI framework**
- [ ] Add `github.com/spf13/cobra` to `go.mod`
- [ ] Create `cmd/holt/main.go` with root command
- [ ] Create `cmd/holt/commands/` package for command implementations
- [ ] Add version information to root command

**Step 2: Create template files**
- [ ] Create `internal/scaffold/templates/` directory
- [ ] Create `holt.yml.tmpl` - minimal working configuration with comments
- [ ] Create `Dockerfile.tmpl` - Alpine-based container with bash
- [ ] Create `run.sh.tmpl` - Simple greeter demonstrating stdin/stdout contract
- [ ] Create `README.md.tmpl` - Documentation for the example agent

**Step 3: Implement Git validation**
- [ ] Create `internal/git/checker.go` with GitChecker interface
- [ ] Implement `IsGitRepository()` using `git rev-parse --git-dir`
- [ ] Implement `GetGitRoot()` using `git rev-parse --show-toplevel`
- [ ] Implement `IsGitRoot(currentDir)` comparing current dir with git root
- [ ] Add clear error messages for each failure case

**Step 4: Implement file existence checks**
- [ ] Create `internal/scaffold/validator.go`
- [ ] Implement `CheckExisting()` to check for `holt.yml`
- [ ] Implement `CheckExisting()` to check for `agents/` directory
- [ ] Return clear error messages listing what exists

**Step 5: Implement scaffolding logic**
- [ ] Create `internal/scaffold/initializer.go`
- [ ] Implement `Initialize(force bool)` main orchestration function
- [ ] Implement template rendering from embedded FS
- [ ] Implement directory creation (`agents/example-agent/`)
- [ ] Implement file writing for all template files
- [ ] Add error handling for permission issues

**Step 6: Implement --force logic**
- [ ] If `--force` and `holt.yml` exists: print warning, remove file
- [ ] If `--force` and `agents/` exists: print warning, remove directory
- [ ] Proceed with normal initialization after cleanup

**Step 7: Implement success output**
- [ ] Create formatted success message with checkmarks
- [ ] List all created files
- [ ] Include actionable next steps
- [ ] Include .gitignore advice
- [ ] Include documentation link

**Step 8: Wire up the init command**
- [ ] Create `cmd/holt/commands/init.go`
- [ ] Define command with Cobra
- [ ] Add `--force` flag
- [ ] Wire to scaffold.Initialize()
- [ ] Add to root command in main.go

**Step 9: Testing**
- [ ] Unit tests for Git validation logic
- [ ] Unit tests for template rendering
- [ ] Integration tests with real Git repository
- [ ] E2E test: success case
- [ ] E2E test: fail when holt.yml exists
- [ ] E2E test: succeed with --force
- [ ] E2E test: fail when not at Git root
- [ ] E2E test: fail when not in Git repo

### **3.3. Performance & resource considerations**

* **Resource usage:**
  - Minimal - just creates files on disk
  - No network calls
  - No database connections
  - Templates embedded in binary (~10KB total)

* **Scalability limits:**
  - Not applicable - single-user command that runs once

* **Performance requirements:**
  - Command should complete in < 1 second
  - Git checks should be < 100ms
  - File creation should be < 500ms
  - No performance bottlenecks expected

### **3.4. Testing strategy**

* **Unit tests:**

  **File: `internal/git/checker_test.go`**
  - Test `IsGitRepository()` in Git repo (returns true)
  - Test `IsGitRepository()` outside Git repo (returns false)
  - Test `GetGitRoot()` returns correct path
  - Test `IsGitRoot()` from root (returns true)
  - Test `IsGitRoot()` from subdirectory (returns false)

  **File: `internal/scaffold/validator_test.go`**
  - Test `CheckExisting()` with no existing files (returns nil)
  - Test `CheckExisting()` with existing holt.yml (returns error)
  - Test `CheckExisting()` with existing agents/ (returns error)

  **File: `internal/scaffold/initializer_test.go`**
  - Test template rendering produces valid YAML
  - Test template rendering produces valid Dockerfile
  - Test template rendering produces valid bash script
  - Test directory creation
  - Test file creation with correct permissions

* **Integration tests:**

  **File: `cmd/holt/commands/init_test.go`**

  Setup: Create temporary directory, run `git init`

  Tests:
  - Test successful initialization creates all expected files
  - Test initialization fails when holt.yml exists (without --force)
  - Test initialization fails when agents/ exists (without --force)
  - Test initialization succeeds with --force when holt.yml exists
  - Test initialization fails when not in Git repo
  - Test initialization fails when in Git subdirectory
  - Test created holt.yml is valid YAML
  - Test created Dockerfile has correct syntax
  - Test created run.sh has execute permissions
  - Test success message is printed

* **E2E tests:**

  **File: `test/e2e/init_test.go`**
  ```bash
  # Happy path
  mkdir /tmp/test-project
  cd /tmp/test-project
  git init
  holt init
  # Verify files exist and have correct content

  # Error case: already initialized
  holt init  # Should fail

  # Force reinitialize
  holt init --force  # Should succeed

  # Error case: not at Git root
  mkdir subdir && cd subdir
  holt init  # Should fail with clear error
  ```

* **Coverage target:** >= 90% for `cmd/holt/commands/init.go` and `internal/scaffold/` package

## **4. Principle compliance check**

### **4.1. YAGNI (You Ain't Gonna Need It)**

**New dependencies:**
- `github.com/spf13/cobra` - CLI framework (required)
- No additional runtime dependencies

**Justification:**
- Cobra is the industry standard and worth the dependency
- No custom CLI parsing (would violate YAGNI)

**YAGNI applied:**
- NOT creating .gitignore (just advise user)
- NOT creating README.md (user can add their own)
- NOT validating holt.yml syntax (deferred to M1.4 when it's consumed)
- NOT supporting Git subdirectories (wait for actual need)
- NOT auto-committing files (user controls Git)

### **4.2. Auditability**

Not applicable - this milestone creates static files, no runtime state.

### **4.3. Small, single-purpose components**

This milestone creates a focused CLI command:
- **Purpose**: Initialize Holt project scaffolding
- **Scope**: Create files only, no validation beyond existence checks
- **NOT included**: Starting services, validating configuration, building images

Clear separation of concerns maintained.

### **4.4. Security considerations**

* **Attack surfaces:**
  - Template injection: Templates are embedded at compile time, not user-provided
  - Path traversal: We create files in current directory only, validate paths
  - Command injection: We execute `git` commands with fixed arguments only

* **Data exposure:**
  - No sensitive data handled
  - All created files are user-visible and expected

* **File system safety:**
  - Check permissions before writing
  - Use `os.FileMode(0644)` for files, `0755` for directories
  - run.sh gets `0755` (executable)

* **Git safety:**
  - Only read Git metadata, never write
  - No Git configuration changes
  - No automatic commits

**Security note**: This is a local development tool. No network access, no credential handling.

### **4.5. Backward compatibility**

* **Breaking changes:**
  - This is the initial implementation - no backward compatibility concerns
  - Future changes to template structure could break projects initialized with old version

* **Migration path:**
  - For V1: Template changes are additive (new fields in holt.yml)
  - Users can `holt init --force` to regenerate
  - Existing agents/ directories should be preserved where possible

* **Template versioning:**
  - Templates are coupled to binary version
  - Not adding explicit version field to holt.yml in Phase 1
  - Future: May add `holt_version: '1.0'` field

**Compatibility note**: Users should re-run `holt init --force` when upgrading Holt versions to get updated templates.

### **4.6. Dependency impact**

* **Git requirements:**
  - Requires Git 2.0+ (for `rev-parse --show-toplevel`)
  - Git must be in PATH
  - Project must be initialized as Git repository

* **Go version:**
  - Requires Go 1.24 (for embed directive and modern features)
  - Cobra requires Go 1.18+

* **Operating system:**
  - Cross-platform (Linux, macOS, Windows)
  - Uses only Go standard library for file operations
  - Git command execution is OS-agnostic

* **Build dependencies:**
  - Cobra is the only external runtime dependency
  - No build-time code generation needed

**Dependency note**: Git is a hard requirement for Holt's architecture, so requiring it at init is appropriate.

## **5. Definition of done**

*This checklist must be fully satisfied for the milestone to be considered complete.*

* [ ] Cobra CLI framework integrated
* [ ] `holt init` command implemented and functional
* [ ] `--force` flag works correctly (overwrites existing files)
* [ ] Git repository check implemented (`git rev-parse --git-dir`)
* [ ] Git root check implemented (must run from root)
* [ ] Template files created and embedded:
  * [ ] holt.yml.tmpl
  * [ ] Dockerfile.tmpl
  * [ ] run.sh.tmpl
  * [ ] README.md.tmpl
* [ ] Scaffolding creates correct directory structure
* [ ] All files created with correct permissions
* [ ] Success message displays created files and next steps
* [ ] Error messages are clear and actionable:
  * [ ] Not in Git repository
  * [ ] Not at Git root
  * [ ] Files already exist (without --force)
* [ ] Unit tests pass with >= 90% coverage
* [ ] Integration tests pass (with real Git repository)
* [ ] E2E test passes: Initialize, verify files, verify content
* [ ] `go vet` and `golint` pass with no warnings
* [ ] All exported functions have godoc comments
* [ ] Created holt.yml is valid YAML
* [ ] Created Dockerfile builds successfully
* [ ] Created run.sh has execute permissions and valid bash syntax
* [ ] No TODOs or FIXMEs remain in code
* [ ] Code review completed (if human developer)

## **6. Error scenarios & edge cases**

### **6.1. Failure modes**

**Failure: Not in a Git repository**
- **Detection**: `git rev-parse --git-dir` returns error
- **Response**:
  ```
  Error: Not a Git repository

  Holt requires initialization from within a Git repository.

  Run 'git init' first, then 'holt init'
  ```
- **Recovery**: User runs `git init`, then retries

**Failure: Not at Git repository root**
- **Detection**: Current directory != `git rev-parse --show-toplevel`
- **Response**:
  ```
  Error: Must run from Git repository root

  Git root: /home/user/project
  Current directory: /home/user/project/src

  Please cd to the Git root and run 'holt init'
  ```
- **Recovery**: User navigates to Git root, then retries

**Failure: holt.yml already exists (without --force)**
- **Detection**: `os.Stat("holt.yml")` succeeds
- **Response**:
  ```
  Error: Project already initialized

  Found existing holt.yml

  Use 'holt init --force' to reinitialize (this will overwrite existing configuration)
  ```
- **Recovery**: User runs with --force or manually removes file

**Failure: agents/ directory exists (without --force)**
- **Detection**: `os.Stat("agents")` succeeds
- **Response**:
  ```
  Error: agents/ directory already exists

  Use 'holt init --force' to reinitialize (this will remove existing agents/ directory)
  ```
- **Recovery**: User runs with --force or manually removes directory

**Failure: Permission denied creating files**
- **Detection**: `os.WriteFile()` or `os.MkdirAll()` returns permission error
- **Response**:
  ```
  Error: Permission denied

  Could not create holt.yml: permission denied

  Check directory permissions and try again
  ```
- **Recovery**: User fixes permissions

**Failure: Git command not found**
- **Detection**: `exec.Command("git")` returns "executable file not found"
- **Response**:
  ```
  Error: Git not found

  Holt requires Git to be installed and available in PATH

  Install Git: https://git-scm.com/downloads
  ```
- **Recovery**: User installs Git

### **6.2. Concurrency considerations**

* **Thread safety**: Not applicable - single-threaded CLI command
* **Multiple executions**: If user runs `holt init` twice simultaneously:
  - First wins, second likely fails on file creation
  - No race condition protection needed (user error, not tool error)
  - File system provides atomicity for individual file creates

### **6.3. Edge case handling**

**Edge case: Empty Git repository (no commits)**
- **Handling**: Allow initialization - agents will create initial commit
- **Rationale**: Fresh repos are valid initialization targets

**Edge case: Detached HEAD state**
- **Handling**: Allow initialization - Git root check still works
- **Rationale**: Not our concern, user can fix Git state separately

**Edge case: Git submodule**
- **Handling**: Treat as separate repository (has own .git)
- **Rationale**: Submodules are independent Git repos

**Edge case: Existing agents/ with other agents**
- **Handling**: With --force, remove entire agents/ directory
- **Rationale**: --force means "start fresh", explicitly destructive
- **User warning**: Show clear message about what will be removed

**Edge case: Read-only file system**
- **Handling**: Fail with permission error (standard behavior)
- **Rationale**: Cannot work around fundamental constraint

**Edge case: Very long file paths (Windows MAX_PATH)**
- **Handling**: Rely on Go's path handling (supports long paths on Windows 10+)
- **Rationale**: Modern Go handles this correctly

**Edge case: Non-ASCII characters in directory names**
- **Handling**: Full Unicode support via Go's standard library
- **Test**: Verify with test directory containing emoji/Chinese characters

## **7. Open questions & decisions**

**Q1: Should we validate the created holt.yml is valid YAML?**
- **Decision**: YES - parse with YAML library after creation to verify
- **Rationale**: Catch template bugs immediately, fail fast

**Q2: Should we create example-agent/README.md?**
- **Decision**: YES - include brief documentation in example agent
- **Rationale**: Makes example self-documenting, educational value

**Q3: Should --force preserve existing custom agents?**
- **Decision**: NO - --force is nuclear option, removes everything
- **Rationale**: Simple semantics, prevents partial state
- **Alternative**: User can manually backup agents/ before --force

**Q4: Should we auto-commit the created files?**
- **Decision**: NO - let user control Git commits
- **Rationale**: YAGNI, user might want to review/modify first

**Q5: Should we check if Docker is installed?**
- **Decision**: NO - defer to M1.4 when Docker is actually used
- **Rationale**: Not needed for init, might confuse users

**Q6: Should example agent use jq for JSON parsing?**
- **Decision**: NO - use grep/sed for simplicity in Phase 1
- **Rationale**: Reduces container dependencies, Phase 1 agents don't execute anyway
- **Future**: Phase 2 example can use proper JSON parser

**✅ All questions resolved** - ready for implementation.

## **8. AI agent implementation guidance**

### **8.1. Development approach**

**Start with the simplest path:**
1. Set up Cobra CLI framework and basic command structure
2. Implement Git validation (most critical, fail-fast)
3. Create embedded templates (static content)
4. Implement file writing logic (straightforward)
5. Add --force flag logic (builds on file writing)
6. Implement success output formatting
7. Add comprehensive tests

**Write tests alongside implementation:**
- Start with Git validation tests (critical path)
- Test template rendering before file writing
- Integration tests after file writing works
- E2E tests last (full user journey)

**Defensive programming:**
- Validate all paths before writing
- Check permissions before creating directories
- Wrap all errors with context
- Clean up on partial failure (best effort)

### **8.2. Common pitfalls to avoid**

❌ **Pitfall**: Forgetting to make run.sh executable
✅ **Solution**: Use `os.FileMode(0755)` explicitly

❌ **Pitfall**: Template syntax errors in embedded files
✅ **Solution**: Test template rendering in unit tests

❌ **Pitfall**: Not handling Windows path separators
✅ **Solution**: Use `filepath` package, not string concatenation

❌ **Pitfall**: Comparing paths with string equality
✅ **Solution**: Use `filepath.Clean()` before comparing

❌ **Pitfall**: Git command failure when Git not installed
✅ **Solution**: Check exec error and provide helpful message

❌ **Pitfall**: Creating files with wrong ownership/permissions
✅ **Solution**: Use explicit FileMode, test on multiple OSes

❌ **Pitfall**: Not validating YAML after template rendering
✅ **Solution**: Parse with yaml.Unmarshal() to verify

### **8.3. Integration checklist**

**Pre-implementation verification:**
* [x] M1.1 is complete (types defined for future holt.yml parsing)
* [x] M1.2 is complete (client available for future commands)
* [x] No dependencies on M1.4, M1.5, M1.6

**Post-implementation verification:**
* [ ] M1.4 can parse created holt.yml
* [ ] Created Dockerfile builds successfully
* [ ] Created run.sh executes without errors
* [ ] No circular dependencies in CLI commands
* [ ] Help text is clear and accurate

## **9. Operational readiness**

### **9.1. Monitoring and observability**

**Metrics:** Not applicable - single-execution CLI command

**Logging:**
- Print to stdout: Success messages, file creation confirmations
- Print to stderr: Error messages, warnings

**Health checks:** Not applicable - no persistent process

**Diagnostics**: Clear error messages for all failure modes

### **9.2. Rollback and disaster recovery**

**Feature flag:** Not applicable - CLI command

**Rollback procedure:**
- User can delete created files manually
- Or run `holt init --force` with updated binary

**Data migration:** Not applicable for V1 (first release)

**Recovery time:** Immediate (delete files and re-run)

### **9.3. Documentation and training**

**CLI documentation:**
- [ ] `holt init --help` shows clear usage
- [ ] `holt --help` lists init command
- [ ] Examples in help text

**API documentation:**
- [ ] Godoc comments on all exported functions
- [ ] Package documentation for internal/scaffold

**User guide:**
- [ ] Getting started documentation
- [ ] Explanation of created files
- [ ] Next steps after initialization

**Troubleshooting:**
- Common error: "Not a Git repository" → Install Git
- Common error: "Already initialized" → Use --force
- Common error: "Not at Git root" → Navigate to root

## **10. Self-validation checklist**

### **Before starting implementation:**

* [x] I understand how this feature aligns with the current phase (Phase 1 - Foundation)
* [x] All success criteria (section 1.3) are measurable and testable
* [x] I have considered every component in section 2 explicitly
* [x] All design decisions (section 3.1) are justified and documented
* [x] Git root requirement is clearly understood and enforced

### **During implementation:**

* [ ] I am implementing the simplest solution that meets success criteria
* [ ] All error scenarios (section 6) are being handled, not just happy path
* [ ] Tests are being written alongside code (TDD approach)
* [ ] Git validation is working correctly (tested with real repos)
* [ ] Templates render correctly and produce valid files

### **Before submission:**

* [ ] All items in Definition of Done (section 5) are complete
* [ ] All unit tests pass
* [ ] All integration tests pass with real Git repository
* [ ] E2E test demonstrates full user journey
* [ ] Test coverage is >= 90%
* [ ] Documentation is complete (godoc + help text)
* [ ] No TODOs or placeholder code remains
* [ ] Code follows Go conventions and passes `go vet`
* [ ] Created files have been manually tested:
  * [ ] holt.yml is valid YAML
  * [ ] Dockerfile builds successfully
  * [ ] run.sh executes without errors
