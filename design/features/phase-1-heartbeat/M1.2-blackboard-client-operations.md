# **Feature design: M1.2 - Blackboard Client Operations**

**Purpose**: Redis client library for CRUD operations and Pub/Sub subscriptions
**Scope**: Foundation for all Sett components that interact with Redis
**Estimated tokens**: ~4,500 tokens

Associated phase: **Heartbeat (Phase 1)**
Status: **Draft**

***Template purpose:*** *This document is a blueprint for a single, implementable milestone. Its purpose is to provide an unambiguous specification for a developer (human or AI) to build a feature that is consistent with Sett's architecture and guiding principles.*

## **1. The 'why': goal and success criteria**

### **1.1. Goal statement**

Provide a type-safe, instance-scoped Redis client library that enables all Sett components to perform CRUD operations on artefacts, claims, and bids, manage thread tracking, and subscribe to real-time events.

### **1.2. User story**

As a Sett component developer (building orchestrator, CLI, or cubs), I need a reliable Go client library that abstracts Redis operations behind type-safe methods so that I can focus on business logic without dealing with raw Redis commands, key formatting, or serialization concerns.

### **1.3. Success criteria**

* The orchestrator can create claims and subscribe to artefact events using simple, type-safe method calls
* The CLI can create artefacts without knowing Redis key patterns or hash serialization
* All Redis operations use the correct instance namespace automatically
* Pub/Sub subscriptions deliver full artefact/claim objects in real-time with graceful cleanup
* Thread tracking operations (add version, get latest) work correctly with ZSET scores
* Connection failures return clear errors that callers can handle appropriately
* All operations support context-based cancellation and timeouts

**Validation questions:**
* ✅ Can each success criterion be automated as a test? Yes - all are unit/integration testable
* ✅ Does each criterion represent user-visible value? Yes - enables orchestrator and CLI (M1.5, M1.6)
* ✅ Are the criteria specific enough to avoid ambiguity? Yes - specific method calls and behaviors defined

### **1.4. Non-goals**

* **NOT in scope**: Caching layer (may add later if performance requires)
* **NOT in scope**: Optimistic locking or versioning (single orchestrator in V1 means no contention)
* **NOT in scope**: Batch operations or pipelining (single operations are sufficient for V1)
* **NOT in scope**: Connection retry logic beyond go-redis defaults (use defaults)
* **NOT in scope**: Monitoring/metrics hooks (that's M4.2 - Health Checks)
* **NOT in scope**: Lua scripts for atomic multi-key operations (not needed in V1)
* **NOT in scope**: GetVersionHistory for threads (deferred to Phase 2 when agent context assembly is implemented)
* **NOT in scope**: TTL management for keys (artefacts/claims are permanent in V1)
* **NOT in scope**: Redis cluster support (single Redis instance only for V1)
* **NOT in scope**: Orchestrator business logic, claim lifecycle state machine, or bidding logic (M1.5 and Phase 2)

## **2. The 'what': component impact analysis**

**Critical validation questions for this entire section:**
* ✅ Have I explicitly considered EVERY component (Blackboard, Orchestrator, Cub, CLI)?
* ✅ For components marked "No changes" - am I absolutely certain this feature doesn't affect them?
* ✅ Do my changes maintain the contracts and interfaces defined in the design documents?
* ✅ Will this feature work correctly with both single-instance and scaled agents (controller-worker pattern)?

### **2.1. Blackboard changes**

* **New/modified data structures:**

  **New Go package: `pkg/blackboard` (extends M1.1)** - Client API added to existing package

  ```go
  // Client provides instance-scoped Redis operations for the blackboard
  type Client struct {
      rdb          *redis.Client
      instanceName string
  }

  // NewClient creates a new blackboard client for the specified instance.
  // The client automatically namespaces all keys and channels with the instance name.
  func NewClient(redisOpts *redis.Options, instanceName string) *Client

  // Close closes the Redis connection. Implements io.Closer.
  func (c *Client) Close() error

  // Ping verifies Redis connectivity. Useful for health checks.
  func (c *Client) Ping(ctx context.Context) error
  ```

* **Artefact CRUD operations:**

  ```go
  // CreateArtefact writes an artefact to Redis and publishes an event.
  // Validates the artefact before writing. Returns error if validation fails or Redis operation fails.
  // Publishes full artefact JSON to sett:{instance}:artefact_events after successful write.
  func (c *Client) CreateArtefact(ctx context.Context, a *Artefact) error

  // GetArtefact retrieves an artefact by ID.
  // Returns (nil, redis.Nil) if the artefact doesn't exist.
  func (c *Client) GetArtefact(ctx context.Context, artefactID string) (*Artefact, error)

  // ArtefactExists checks if an artefact exists without fetching it.
  func (c *Client) ArtefactExists(ctx context.Context, artefactID string) (bool, error)
  ```

* **Claim CRUD operations:**

  ```go
  // CreateClaim writes a claim to Redis and publishes an event.
  // Validates the claim before writing.
  // Publishes full claim JSON to sett:{instance}:claim_events after successful write.
  func (c *Client) CreateClaim(ctx context.Context, claim *Claim) error

  // GetClaim retrieves a claim by ID.
  // Returns (nil, redis.Nil) if the claim doesn't exist.
  func (c *Client) GetClaim(ctx context.Context, claimID string) (*Claim, error)

  // UpdateClaim replaces an existing claim with new data (full HMSET replacement).
  // Used by orchestrator to update status and granted agents as claim progresses through phases.
  // Validates the claim before writing.
  func (c *Client) UpdateClaim(ctx context.Context, claim *Claim) error

  // ClaimExists checks if a claim exists without fetching it.
  func (c *Client) ClaimExists(ctx context.Context, claimID string) (bool, error)
  ```

* **Bid operations:**

  ```go
  // SetBid records an agent's bid on a claim.
  // Uses HSET on sett:{instance}:claim:{claim_id}:bids with key=agentName, value=bidType.
  // Validates the bid type before writing.
  func (c *Client) SetBid(ctx context.Context, claimID string, agentName string, bidType BidType) error

  // GetAllBids retrieves all bids for a claim as a map of agent name to bid type.
  // Returns empty map if no bids exist (not an error).
  func (c *Client) GetAllBids(ctx context.Context, claimID string) (map[string]BidType, error)
  ```

* **Thread tracking operations:**

  ```go
  // AddVersionToThread adds an artefact to a version thread.
  // Uses ZADD with score=version to maintain sorted order.
  func (c *Client) AddVersionToThread(ctx context.Context, logicalID string, artefactID string, version int) error

  // GetLatestVersion retrieves the artefact ID of the highest version in a thread.
  // Returns ("", redis.Nil) if the thread doesn't exist.
  func (c *Client) GetLatestVersion(ctx context.Context, logicalID string) (artefactID string, version int, error)
  ```

* **Pub/Sub subscriptions:**

  ```go
  // Subscription represents an active Pub/Sub subscription.
  // Caller must call Close() when done to clean up resources.
  type Subscription struct {
      events <-chan *Artefact // or *Claim, depending on subscription type
      cancel func()
  }

  // Events returns the channel of events.
  func (s *Subscription) Events() <-chan *Artefact

  // Close stops the subscription and cleans up resources. Implements io.Closer.
  func (s *Subscription) Close() error

  // SubscribeArtefactEvents subscribes to artefact creation events for this instance.
  // Returns a Subscription that delivers full artefact objects.
  // Caller must call subscription.Close() when done.
  // Context cancellation also stops the subscription.
  func (c *Client) SubscribeArtefactEvents(ctx context.Context) (*Subscription, error)

  // SubscribeClaimEvents subscribes to claim creation events for this instance.
  // Returns a Subscription that delivers full claim objects.
  func (c *Client) SubscribeClaimEvents(ctx context.Context) (*ClaimSubscription, error)
  ```

* **Error helpers:**

  ```go
  // IsNotFound returns true if the error is a Redis "key not found" error (redis.Nil).
  func IsNotFound(err error) bool
  ```

### **2.2. Orchestrator changes**

* **New/modified logic:**
  Orchestrator (M1.5) will import this package and use it to:
  - Subscribe to artefact events: `client.SubscribeArtefactEvents(ctx)`
  - Get artefact details: `client.GetArtefact(ctx, artefactID)`
  - Create claims: `client.CreateClaim(ctx, claim)`
  - Update claims: `client.UpdateClaim(ctx, claim)`
  - Get bids: `client.GetAllBids(ctx, claimID)`
  - Track threads: `client.AddVersionToThread(ctx, logicalID, artefactID, version)`

* **New/modified configurations (sett.yml):**
  No changes to sett.yml in this milestone. Redis connection details will be passed via environment variables.

### **2.3. Agent cub changes**

* **New/modified logic:**
  Agent cubs (Phase 2) will import this package and use it to:
  - Subscribe to claim events: `client.SubscribeClaimEvents(ctx)`
  - Get claim details: `client.GetClaim(ctx, claimID)`
  - Get artefact: `client.GetArtefact(ctx, artefactID)`
  - Submit bids: `client.SetBid(ctx, claimID, agentName, bidType)`

* **Changes to the tool execution contract (stdin/stdout):**
  No changes in this milestone. The contract is defined but not implemented yet.

### **2.4. CLI changes**

* **New/modified commands:**
  CLI (M1.6 - forage command) will import this package and use it to:
  - Create artefacts: `client.CreateArtefact(ctx, artefact)`
  - Check if artefact exists: `client.ArtefactExists(ctx, artefactID)`

* **Changes to user output:**
  No changes to user-facing output in this milestone.

## **3. The 'how': implementation & testing plan**

### **3.1. Key design decisions & risks**

**Decision 1: Instance-bound client vs instance-per-call**

* **Rationale**: Client is bound to an instance at construction (`NewClient(opts, "default-1")`). All operations automatically use that instance's namespace.
* **Benefits**: Simpler API (fewer parameters), impossible to accidentally use wrong instance, matches "one client per instance" component model
* **Risk**: If a component needs to access multiple instances, it must create multiple clients. Mitigation: This is rare in V1 and acceptable.

**Decision 2: Pub/Sub event payload format**

* **Rationale**: Publish full artefact/claim JSON in Pub/Sub messages, not just UUIDs.
* **Benefits**: Subscribers get complete data in one round trip, no race condition between event and GET, matches event-driven architecture best practices
* **Risk**: Larger message size. Mitigation: Typical artefact is <5KB, well within Redis limits.

**Decision 3: Channel-based Pub/Sub with explicit Subscription cleanup**

* **Rationale**: Return `Subscription` object with `Events()` method and `Close()` for cleanup. Background goroutine manages Redis Pub/Sub and event unmarshaling.
* **Benefits**: Idiomatic Go (channels + io.Closer), context cancellation support, explicit lifecycle management
* **Risk**: Goroutine leaks if caller forgets to Close(). Mitigation: Document clearly, context cancellation also stops goroutine.

**Decision 4: Validation in client methods**

* **Rationale**: Call `Validate()` on artefacts and claims before writing to Redis.
* **Benefits**: Fail fast with clear errors, prevent invalid data in Redis, consistent validation across all writers
* **Risk**: Slight performance overhead. Mitigation: Validation is very fast (<1ms), worth the safety.

**Decision 5: Full claim replacement in UpdateClaim**

* **Rationale**: `UpdateClaim()` does full HMSET replacement of all claim fields, not partial updates.
* **Benefits**: Simple API, atomic update in Redis (HMSET is atomic for the hash), matches orchestrator workflow (status + granted agents change together)
* **Risk**: Race conditions if multiple processes update same claim. Mitigation: V1 has single orchestrator, so no contention. Can add optimistic locking later via version field if needed.

**Decision 6: Redis library choice (go-redis/v9)**

* **Rationale**: Use `github.com/redis/go-redis/v9` as the underlying Redis client.
* **Benefits**: Most popular Go Redis client, context-based API, built-in connection pooling, excellent Pub/Sub support, active maintenance
* **Risk**: Dependency on external library. Mitigation: go-redis is battle-tested, widely used, and stable.

### **3.2. Implementation steps**

**Step 1: Add go-redis dependency**
- [ ] Update `go.mod`: `require github.com/redis/go-redis/v9`
- [ ] Run `go mod download`

**Step 2: Client construction and connection management**
- [ ] Create `pkg/blackboard/client.go`
- [ ] Implement `Client` struct with `rdb *redis.Client` and `instanceName string`
- [ ] Implement `NewClient(redisOpts *redis.Options, instanceName string) *Client`
- [ ] Implement `Close() error` - calls `c.rdb.Close()`
- [ ] Implement `Ping(ctx context.Context) error` - calls `c.rdb.Ping(ctx)`

**Step 3: Artefact CRUD operations**
- [ ] Implement `CreateArtefact(ctx, a *Artefact) error`
  - Call `a.Validate()`
  - Generate key with `ArtefactKey(c.instanceName, a.ID)`
  - Convert to hash with `ArtefactToHash(a)`
  - Write with `c.rdb.HSet(ctx, key, hash)`
  - Marshal artefact to JSON
  - Publish to `ArtefactEventsChannel(c.instanceName)` with `c.rdb.Publish(ctx, channel, json)`
- [ ] Implement `GetArtefact(ctx, artefactID string) (*Artefact, error)`
  - Generate key with `ArtefactKey(c.instanceName, artefactID)`
  - Read with `c.rdb.HGetAll(ctx, key)`
  - Return `(nil, redis.Nil)` if key doesn't exist
  - Convert with `HashToArtefact(hashData)`
- [ ] Implement `ArtefactExists(ctx, artefactID string) (bool, error)`
  - Use `c.rdb.Exists(ctx, ArtefactKey(c.instanceName, artefactID))`

**Step 4: Claim CRUD operations**
- [ ] Implement `CreateClaim(ctx, claim *Claim) error`
  - Similar to CreateArtefact: validate, hash, write, publish
- [ ] Implement `GetClaim(ctx, claimID string) (*Claim, error)`
  - Similar to GetArtefact: read, unmarshal
- [ ] Implement `UpdateClaim(ctx, claim *Claim) error`
  - Validate, convert to hash, HMSET (full replacement)
- [ ] Implement `ClaimExists(ctx, claimID string) (bool, error)`
  - Use EXISTS command

**Step 5: Bid operations**
- [ ] Implement `SetBid(ctx, claimID, agentName string, bidType BidType) error`
  - Validate bid type with `bidType.Validate()`
  - Use `c.rdb.HSet(ctx, ClaimBidsKey(c.instanceName, claimID), agentName, string(bidType))`
- [ ] Implement `GetAllBids(ctx, claimID string) (map[string]BidType, error)`
  - Use `c.rdb.HGetAll(ctx, ClaimBidsKey(c.instanceName, claimID))`
  - Convert string values to BidType

**Step 6: Thread tracking operations**
- [ ] Implement `AddVersionToThread(ctx, logicalID, artefactID string, version int) error`
  - Use `c.rdb.ZAdd(ctx, ThreadKey(c.instanceName, logicalID), redis.Z{Score: ThreadScore(version), Member: artefactID})`
- [ ] Implement `GetLatestVersion(ctx, logicalID string) (string, int, error)`
  - Use `c.rdb.ZRevRangeWithScores(ctx, ThreadKey(c.instanceName, logicalID), 0, 0)` to get highest score member
  - Convert score back to version with `VersionFromScore(score)`
  - Return `("", 0, redis.Nil)` if thread is empty

**Step 7: Pub/Sub subscription infrastructure**
- [ ] Create `Subscription` struct with `events` channel and `cancel` func
- [ ] Implement `Subscription.Events() <-chan *Artefact`
- [ ] Implement `Subscription.Close() error`
- [ ] Create `ClaimSubscription` struct (same pattern for claims)

**Step 8: Artefact event subscription**
- [ ] Implement `SubscribeArtefactEvents(ctx) (*Subscription, error)`
  - Create `pubsub := c.rdb.Subscribe(ctx, ArtefactEventsChannel(c.instanceName))`
  - Create output channel `out := make(chan *Artefact, 10)` (buffered to prevent blocking)
  - Start goroutine to read from `pubsub.Channel()` and unmarshal JSON to artefacts
  - Return Subscription with `events: out` and `cancel: func() { pubsub.Close() }`

**Step 9: Claim event subscription**
- [ ] Implement `SubscribeClaimEvents(ctx) (*ClaimSubscription, error)`
  - Same pattern as artefact subscription, but for claims

**Step 10: Error helper**
- [ ] Implement `IsNotFound(err error) bool`
  - Use `errors.Is(err, redis.Nil)`

**Step 11: Testing**
- [ ] Write unit tests with miniredis (see section 3.4)
- [ ] Write integration tests with testcontainers-go (see section 3.4)

### **3.3. Performance & resource considerations**

* **Resource usage:**
  - Each Client instance holds one go-redis connection pool (default: 10 connections)
  - Each Subscription spawns one goroutine (cleaned up on Close())
  - Memory: Minimal overhead beyond go-redis itself
  - Network: One round trip per operation (no batching in V1)

* **Scalability limits:**
  - Single Redis instance limit: ~50K ops/sec typical
  - Pub/Sub: Redis can handle thousands of subscribers per channel
  - V1 workload (single orchestrator, few agents): Well within limits

* **Performance requirements:**
  - CRUD operations: < 10ms p99 (depends on Redis latency)
  - Pub/Sub delivery: < 50ms from publish to subscriber receipt
  - No specific throughput requirements for V1 (single orchestrator is low volume)

### **3.4. Testing strategy**

* **Unit tests with miniredis:**

  **File: `pkg/blackboard/client_test.go`**

  **Setup:**
  ```go
  import "github.com/alicebob/miniredis/v2"

  func setupTestClient(t *testing.T) (*Client, *miniredis.Miniredis) {
      mr := miniredis.NewMiniRedis()
      mr.Start()
      t.Cleanup(mr.Close)

      client := NewClient(&redis.Options{Addr: mr.Addr()}, "test-instance")
      t.Cleanup(func() { client.Close() })

      return client, mr
  }
  ```

  **Tests:**
  - Test `NewClient()` and `Ping()`
  - Test `CreateArtefact()` and `GetArtefact()` round-trip
  - Test `CreateArtefact()` with invalid artefact (validation failure)
  - Test `GetArtefact()` with non-existent ID (returns redis.Nil)
  - Test `ArtefactExists()` true and false cases
  - Test `CreateClaim()` and `GetClaim()` round-trip
  - Test `UpdateClaim()` full replacement
  - Test `SetBid()` and `GetAllBids()` with multiple agents
  - Test `AddVersionToThread()` and `GetLatestVersion()`
  - Test `GetLatestVersion()` on empty thread (returns redis.Nil)
  - Test instance namespacing (create client with "instance-1", verify keys have correct prefix)
  - Test `IsNotFound()` helper

  **Pub/Sub tests with miniredis:**
  - Test `SubscribeArtefactEvents()` receives published artefact
  - Test `SubscribeClaimEvents()` receives published claim
  - Test subscription cleanup on `Close()`
  - Test subscription cleanup on context cancellation
  - Test multiple subscribers to same channel

* **Integration tests with testcontainers-go:**

  **File: `pkg/blackboard/client_integration_test.go`**
  ```go
  //go:build integration
  ```

  **Setup:**
  ```go
  import "github.com/testcontainers/testcontainers-go"

  func setupRealRedis(t *testing.T) *Client {
      ctx := context.Background()
      req := testcontainers.ContainerRequest{
          Image:        "redis:7-alpine",
          ExposedPorts: []string{"6379/tcp"},
      }
      redisC, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
          ContainerRequest: req,
          Started:          true,
      })
      require.NoError(t, err)
      t.Cleanup(func() { redisC.Terminate(ctx) })

      host, _ := redisC.Host(ctx)
      port, _ := redisC.MappedPort(ctx, "6379")

      client := NewClient(&redis.Options{
          Addr: fmt.Sprintf("%s:%s", host, port.Port()),
      }, "integration-test")
      t.Cleanup(func() { client.Close() })

      return client
  }
  ```

  **Tests:**
  - Test all CRUD operations against real Redis
  - Test Pub/Sub with real Redis (verify message delivery)
  - Test concurrent operations (multiple goroutines writing/reading)
  - Test ZSET ordering for thread tracking
  - Test connection failure handling

* **Coverage target:** >= 85% for client.go (lower than M1.1's 90% because of error paths that are hard to trigger)

## **4. Principle compliance check**

### **4.1. YAGNI (You Ain't Gonna Need It)**

**New dependencies:**
- `github.com/redis/go-redis/v9` - Redis client (required)
- `github.com/alicebob/miniredis/v2` - In-memory Redis for testing (dev dependency)
- `github.com/testcontainers/testcontainers-go` - Real Redis containers for integration tests (dev dependency)

**Justification:**
- go-redis is the standard, battle-tested Go Redis client. Not worth implementing our own.
- miniredis enables fast, zero-config unit tests
- testcontainers provides real Redis integration tests without manual setup

**YAGNI applied:**
- NOT adding caching (wait for actual performance need)
- NOT adding batch operations (single ops are sufficient)
- NOT adding optimistic locking (no contention in V1)
- NOT adding connection retry beyond defaults (go-redis handles this)

### **4.2. Auditability**

This milestone provides the foundation for auditability:
- All artefact creates are written to Redis (permanent record)
- All claim creates and updates are written to Redis (permanent record)
- Pub/Sub events enable real-time auditing by subscribing to event streams
- Thread tracking maintains complete version history

The client library itself doesn't add auditing features, but enables them by making all state changes observable.

### **4.3. Small, single-purpose components**

This milestone creates a focused client library:
- **Purpose**: Redis CRUD and Pub/Sub for blackboard entities
- **Scope**: Data access layer only, no business logic
- **NOT included**: Orchestrator logic, claim lifecycle, bidding rules (those are M1.5 and Phase 2)

Clear separation of concerns maintained: client provides data access, components use client to implement logic.

### **4.4. Security considerations**

* **Attack surfaces:**
  - Redis connection: Assumes Redis is on trusted network, no authentication in V1
  - Future: Add Redis AUTH support via go-redis Options
  - No input sanitization needed (Redis is binary-safe, we use HSET not eval)

* **Data exposure:**
  - Artefact payloads are opaque strings - client doesn't inspect or log them
  - No sensitive data logging in client code

* **Container isolation:**
  - Not applicable - this is a library, not a service

* **Network security:**
  - Redis traffic is unencrypted in V1 (assume trusted network)
  - Future: Add TLS support via go-redis Options

**Security note**: This client library assumes Redis is on a trusted network. Production deployments should use Redis AUTH and TLS (go-redis supports both via Options).

### **4.5. Backward compatibility**

* **Breaking changes:**
  - This is the initial client implementation - no backward compatibility concerns
  - Future API changes will be breaking (no versioning plan for V1)

* **Migration path:**
  - For V1: Clean slate assumption (no existing data)
  - Future: If API changes, update all components simultaneously (monorepo makes this feasible)

* **Additive design:**
  - New CRUD methods can be added without breaking existing code
  - New helper functions can be added without breaking existing code
  - Cannot change method signatures without breaking callers

**Compatibility note**: This is the foundational client API. Changes should be carefully considered, but we're not committing to API stability until V1.0 release.

### **4.6. Dependency impact**

* **Redis requirements:**
  - Redis 6.0+ (for ZSET operations and Pub/Sub)
  - Single instance only (no cluster support in V1)
  - No Redis modules required

* **Go version:**
  - Requires Go 1.19+ (for go-redis/v9 context support)
  - Update go.mod: `go 1.19`

* **Build dependencies:**
  - go-redis/v9 - stable, widely used
  - miniredis/v2 - testing only, no runtime impact
  - testcontainers-go - testing only, requires Docker

* **Development environment:**
  - Unit tests: No external dependencies (miniredis)
  - Integration tests: Requires Docker for testcontainers

**Dependency note**: go-redis is a critical runtime dependency. It's stable, widely adopted, and actively maintained. Acceptable risk.

## **5. Definition of done**

*This checklist must be fully satisfied for the milestone to be considered complete.*

* [ ] All implementation steps from section 3.2 are complete
* [ ] `NewClient()` creates client and `Close()` cleans up
* [ ] `CreateArtefact()` validates, writes to Redis, and publishes event
* [ ] `GetArtefact()` retrieves artefact and handles not-found correctly
* [ ] `CreateClaim()` validates, writes, and publishes event
* [ ] `UpdateClaim()` performs full replacement
* [ ] `SetBid()` and `GetAllBids()` work correctly
* [ ] `AddVersionToThread()` and `GetLatestVersion()` work correctly with ZSET
* [ ] `SubscribeArtefactEvents()` delivers full artefacts via channel
* [ ] `SubscribeClaimEvents()` delivers full claims via channel
* [ ] Subscription cleanup works (Close() and context cancellation)
* [ ] All unit tests pass with miniredis
* [ ] All integration tests pass with real Redis (testcontainers)
* [ ] Test coverage for `client.go` is >= 85%
* [ ] `go vet` and `golint` pass with no warnings
* [ ] All exported functions have godoc comments
* [ ] Instance namespacing verified (keys have correct prefix)
* [ ] Round-trip serialization works (Create then Get returns same data)
* [ ] Error cases are handled (connection failure, not found, validation errors)
* [ ] No resource leaks (Close() cleans up connections, subscriptions clean up goroutines)
* [ ] Code review completed (if human developer)
* [ ] No TODOs or FIXMEs remain in code

## **6. Error scenarios & edge cases**

### **6.1. Failure modes**

**Failure: Redis connection failed**
- **Detection**: `Ping()` or first operation returns error
- **Response**: Return wrapped error (e.g., "failed to connect to Redis: connection refused")
- **Recovery**: Caller must retry or fail (no automatic retry in client)

**Failure: Key not found (artefact/claim doesn't exist)**
- **Detection**: `HGetAll()` returns empty map
- **Response**: Return `(nil, redis.Nil)` from Get operations
- **Recovery**: Caller checks with `IsNotFound(err)` and handles appropriately

**Failure: Validation error before write**
- **Detection**: `Validate()` returns error
- **Response**: Return validation error without touching Redis
- **Recovery**: Caller must fix data and retry

**Failure: JSON unmarshal error in Pub/Sub**
- **Detection**: `json.Unmarshal()` fails on received message
- **Response**: Log error (to stderr), skip message, continue subscription
- **Recovery**: Automatic - next message is processed

**Failure: Context cancelled during operation**
- **Detection**: `ctx.Done()` triggers
- **Response**: Redis operation returns context error
- **Recovery**: Caller handles context cancellation appropriately

**Failure: Subscription goroutine panic**
- **Detection**: Panic in event processing goroutine
- **Response**: Recover, close subscription channel, log panic
- **Recovery**: Subscriber sees closed channel, must resubscribe

### **6.2. Concurrency considerations**

* **Thread safety**:
  - go-redis is thread-safe (connection pooling is concurrent-safe)
  - Client is thread-safe by composition
  - No additional synchronization needed in Client

* **Mutable state**:
  - Client has immutable fields after construction (rdb, instanceName)
  - No shared mutable state

* **Race conditions**:
  - UpdateClaim() race: If two processes update same claim simultaneously, last write wins (HMSET is atomic)
  - Mitig: V1 has single orchestrator, so no contention
  - Future: Add version field to Claim for optimistic locking

* **Pub/Sub delivery guarantees**:
  - Redis Pub/Sub is fire-and-forget (at-most-once delivery)
  - If subscriber is slow, messages may be dropped
  - Mitigation: Use buffered channels (10 buffer), document best-effort delivery

### **6.3. Edge case handling**

**Edge case: Empty thread (no versions)**
- **Handling**: `GetLatestVersion()` returns `("", 0, redis.Nil)`
- **Test**: Verify not-found behavior

**Edge case: Duplicate artefact ID**
- **Handling**: `CreateArtefact()` overwrites existing (HSET is idempotent)
- **Rationale**: Artefacts are immutable, so duplicate ID means same data
- **Future**: Check EXISTS first if idempotency is critical

**Edge case: Claim update while claim doesn't exist**
- **Handling**: `UpdateClaim()` creates claim (HMSET creates if not exists)
- **Mitigation**: Caller should use CreateClaim() first, but HMSET is lenient

**Edge case: Nil slices in artefact source_artefacts**
- **Handling**: Serialization converts nil to empty JSON array `[]`
- **Test**: Verify round-trip maintains empty slice

**Edge case: Very long payload strings**
- **Handling**: No length limit enforced (Redis can handle ~512MB values)
- **Rationale**: Payloads are typically git hashes (40 chars) or small JSON

**Edge case: Multiple subscribers to same channel**
- **Handling**: All subscribers receive every message (Redis Pub/Sub broadcasts)
- **Test**: Verify multiple subscriptions work correctly

**Edge case: Subscribe with already-cancelled context**
- **Handling**: Subscription starts but immediately closes
- **Test**: Verify graceful handling

## **7. Open questions & decisions**

**Q1: Should CreateArtefact check for duplicate ID before writing?**
- **Decision**: NO - HSET is idempotent, artefacts are immutable, so duplicate ID means same content
- **Rationale**: YAGNI - add EXISTS check later if idempotency detection is needed

**Q2: Should UpdateClaim require claim to exist first?**
- **Decision**: NO - HMSET creates if not exists
- **Rationale**: Simpler API, caller should use CreateClaim anyway, HMSET is lenient

**Q3: Should Pub/Sub channels be buffered?**
- **Decision**: YES - buffer size 10
- **Rationale**: Prevents slow subscriber from blocking publisher, 10 is reasonable for V1 workload

**Q4: Should we expose raw Redis client for advanced operations?**
- **Decision**: NOT in V1 - client is opaque
- **Rationale**: Keeps API surface small, can add `GetRedisClient()` later if needed

**Q5: Should we validate instance name format?**
- **Decision**: NOT in M1.2 - assume valid from M1.4 (CLI)
- **Rationale**: M1.4 validates instance names, client trusts caller

**Q6: Should Go version be updated from 1.15 to 1.19?**
- **Decision**: YES - go-redis/v9 requires Go 1.18+, use 1.19 for stability
- **Rationale**: Modern Go features (generics, context), no reason to stay on 1.15

**✅ All questions resolved** - ready for implementation.

## **8. AI agent implementation guidance**

### **8.1. Development approach**

**Start with the simplest path:**
1. Update go.mod to Go 1.19 and add go-redis dependency
2. Implement Client struct and constructor (NewClient, Close, Ping)
3. Implement artefact CRUD (CreateArtefact, GetArtefact - simple round-trip)
4. Implement claim CRUD (same pattern as artefact)
5. Implement bid operations (simpler - just HSET/HGETALL)
6. Implement thread operations (ZADD/ZREVRANGE)
7. Implement Pub/Sub (most complex - goroutines and channels)
8. Add error handling and edge cases
9. Write tests incrementally as you implement each function

**Write tests alongside implementation:**
- After implementing CreateArtefact, write test for it immediately
- Use TDD for complex functions (Pub/Sub)
- Run tests frequently (`go test -v ./pkg/blackboard/`)

**Defensive programming:**
- Always validate before writing to Redis
- Handle redis.Nil (not found) explicitly
- Wrap errors with context (e.g., `fmt.Errorf("failed to create artefact: %w", err)`)
- Check for nil pointers before dereferencing

### **8.2. Common pitfalls to avoid**

❌ **Pitfall**: Forgetting to call `Close()` on Client in tests
✅ **Solution**: Use `t.Cleanup(func() { client.Close() })` in test setup

❌ **Pitfall**: Not checking redis.Nil for not-found cases
✅ **Solution**: Always use `if errors.Is(err, redis.Nil)` pattern

❌ **Pitfall**: Creating subscription without cleanup
✅ **Solution**: Document that caller must call `subscription.Close()`, add defer in examples

❌ **Pitfall**: Goroutine leak in Pub/Sub if Close() not called
✅ **Solution**: Ensure goroutine exits on context cancellation AND on Close()

❌ **Pitfall**: Forgetting instance namespace in key generation
✅ **Solution**: Always use helper functions (ArtefactKey, etc.) - never build keys manually

❌ **Pitfall**: Not marshaling to JSON before publishing Pub/Sub
✅ **Solution**: Use `json.Marshal()` before `Publish()`

❌ **Pitfall**: Blocking on unbuffered channel in Pub/Sub
✅ **Solution**: Use buffered channel (size 10) for events

### **8.3. Integration checklist**

**Pre-implementation verification:**
* [x] M1.1 is complete and tested (types and helpers available)
* [x] No breaking changes to M1.1 types (client adds new functionality only)
* [x] Redis connection details will come from environment (M1.4/M1.5 will provide)

**Post-implementation verification:**
* [ ] M1.5 (Orchestrator) can import and use this client
* [ ] M1.6 (CLI forage) can import and use this client
* [ ] Phase 2 (Agent cubs) can import and use this client
* [ ] No circular dependencies in pkg/blackboard
* [ ] No changes needed to M1.1 types (client works with existing types)

## **9. Operational readiness**

### **9.1. Monitoring and observability**

**Metrics:** Not in scope for M1.2 - client is a library, components using it will add metrics (M4.2)

**Logging:** Client returns errors, doesn't log. Components decide what to log.

**Health checks:** `Ping()` method enables health check in components (M4.2 will use this)

**Diagnostics:** Clear error messages enable debugging:
- "failed to connect to Redis: connection refused"
- "invalid artefact: version must be >= 1"
- "artefact not found: 550e8400-..."

### **9.2. Rollback and disaster recovery**

**Feature flag:** Not applicable - this is a library

**Rollback procedure:** If client has bugs, fix and recompile components. No runtime rollback.

**Data migration:** Not applicable for V1 (clean slate)

**Recovery time:** Immediate (recompile + restart components)

### **9.3. Documentation and training**

**CLI documentation:** Not applicable - client is a library

**API documentation:**
- [ ] Godoc comments on all exported types and functions
- [ ] Package-level example in doc.go showing basic usage
- [ ] README in `pkg/blackboard/` with client usage examples (update from M1.1)

**Troubleshooting:**
- Common error: "connection refused" → Check Redis is running
- Common error: "key not found" → Use IsNotFound() helper
- Common error: "invalid artefact" → Check validation rules

**Training needs:** None - standard Go development practices + go-redis documentation

## **10. Self-validation checklist**

### **Before starting implementation:**

* [x] I understand how this feature aligns with the current phase (Phase 1 - Foundation)
* [x] All success criteria (section 1.3) are measurable and testable
* [x] I have considered every component in section 2 explicitly
* [x] All design decisions (section 3.1) are justified and documented
* [x] Dependencies are minimal and justified (go-redis, miniredis, testcontainers)

### **During implementation:**

* [ ] I am implementing the simplest solution that meets success criteria
* [ ] All error scenarios (section 6) are being handled, not just happy path
* [ ] Tests are being written alongside code (not after)
* [ ] I am validating that no breaking changes to M1.1 types are introduced
* [ ] Instance namespacing is working correctly (verified in tests)

### **Before submission:**

* [ ] All items in Definition of Done (section 5) are complete
* [ ] All unit tests pass with miniredis
* [ ] All integration tests pass with real Redis (testcontainers)
* [ ] Test coverage is >= 85% for client.go
* [ ] Documentation is updated (godoc + README)
* [ ] No TODOs or placeholder code remains
* [ ] Code follows Go conventions and passes `go vet`
* [ ] go.mod is updated to Go 1.19 and includes go-redis/v9
* [ ] No resource leaks (tested Close() and subscription cleanup)
