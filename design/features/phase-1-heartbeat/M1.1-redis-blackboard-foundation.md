# **Feature design: M1.1 - Redis Blackboard Foundation**

**Purpose**: Core type definitions and Redis schema for the blackboard
**Scope**: Foundation for all Holt components
**Estimated tokens**: ~3,500 tokens

Associated phase: **Heartbeat (Phase 1)**
Status: **Draft**

***Template purpose:*** *This document is a blueprint for a single, implementable milestone. Its purpose is to provide an unambiguous specification for a developer (human or AI) to build a feature that is consistent with Holt's architecture and guiding principles.*

## **1. The 'why': goal and success criteria**

### **1.1. Goal statement**

Establish type-safe Go definitions and Redis schema patterns as the foundational contract for all Holt components.

### **1.2. User story**

As a Holt developer (human or AI), I need well-defined, type-safe Go structures that represent the blackboard's data model so that I can build orchestrator, pup, and CLI components with confidence that they will correctly interact with Redis and with each other through a shared, validated contract.

### **1.3. Success criteria**

* A Go developer can import `pkg/blackboard` and create valid Artefact, Claim, and Bid instances with compile-time type safety
* All Redis key patterns follow the documented naming convention `holt:{instance_name}:{entity}:{uuid}` and are generated by centralized helper functions
* Serialization and deserialization between Go structs and Redis hashes works correctly with 100% round-trip fidelity
* Invalid data (malformed enums, missing required fields, invalid UUIDs) is caught by validation methods before reaching Redis
* Thread tracking operations (add version, get latest version) have clear, tested utility functions

**Validation questions:**
* ✅ Can each success criterion be automated as a test? Yes - all are unit-testable
* ✅ Does each criterion represent user-visible value? Yes - enables all subsequent development
* ✅ Are the criteria specific enough to avoid ambiguity? Yes - specific technical outcomes defined

### **1.4. Non-goals**

* **NOT in scope**: Redis client connection management (that's M1.2 - Blackboard Client Operations)
* **NOT in scope**: Pub/Sub subscription logic (that's M1.2)
* **NOT in scope**: Actual CRUD operations against Redis (that's M1.2)
* **NOT in scope**: Thread relationship traversal or DAG analysis (future feature)
* **NOT in scope**: Migration or versioning of schema (V1 assumes clean slate)

## **2. The 'what': component impact analysis**

**Critical validation questions for this entire section:**
* ✅ Have I explicitly considered EVERY component (Blackboard, Orchestrator, Pup, CLI)?
* ✅ For components marked "No changes" - am I absolutely certain this feature doesn't affect them?
* ✅ Do my changes maintain the contracts and interfaces defined in the design documents?
* ✅ Will this feature work correctly with both single-instance and scaled agents (controller-worker pattern)?

### **2.1. Blackboard changes**

* **New/modified data structures:**

  **New Go package: `pkg/blackboard`** (public API for all components)

  ```go
  // Core data structures

  // Artefact represents an immutable work product on the blackboard
  type Artefact struct {
      ID               string         `json:"id"`                // UUID
      LogicalID        string         `json:"logical_id"`        // UUID grouping versions
      Version          int            `json:"version"`           // Incrementing version number
      StructuralType   StructuralType `json:"structural_type"`   // Role in orchestration
      Type             string         `json:"type"`              // User-defined domain type
      Payload          string         `json:"payload"`           // Main content
      SourceArtefacts  []string       `json:"source_artefacts"`  // Array of UUIDs
      ProducedByRole   string         `json:"produced_by_role"`  // Agent role or "user"
  }

  // StructuralType defines the role an artefact plays in orchestration flow
  type StructuralType string

  const (
      StructuralTypeStandard  StructuralType = "Standard"
      StructuralTypeReview    StructuralType = "Review"
      StructuralTypeQuestion  StructuralType = "Question"
      StructuralTypeAnswer    StructuralType = "Answer"
      StructuralTypeFailure   StructuralType = "Failure"
      StructuralTypeTerminal  StructuralType = "Terminal"
  )

  // Claim represents the orchestrator's decision about an artefact
  type Claim struct {
      ID                      string      `json:"id"`                         // UUID
      ArtefactID              string      `json:"artefact_id"`                // UUID
      Status                  ClaimStatus `json:"status"`                     // Current lifecycle state
      GrantedReviewAgents     []string    `json:"granted_review_agents"`      // Agent names
      GrantedParallelAgents   []string    `json:"granted_parallel_agents"`    // Agent names
      GrantedExclusiveAgent   string      `json:"granted_exclusive_agent"`    // Single agent name
  }

  // ClaimStatus defines the lifecycle state of a claim
  type ClaimStatus string

  const (
      ClaimStatusPendingReview    ClaimStatus = "pending_review"
      ClaimStatusPendingParallel  ClaimStatus = "pending_parallel"
      ClaimStatusPendingExclusive ClaimStatus = "pending_exclusive"
      ClaimStatusComplete         ClaimStatus = "complete"
      ClaimStatusTerminated       ClaimStatus = "terminated"
  )

  // BidType represents an agent's interest level in a claim
  type BidType string

  const (
      BidTypeReview    BidType = "review"     // Request to review
      BidTypeParallel  BidType = "claim"      // Request to work in parallel
      BidTypeExclusive BidType = "exclusive"  // Request exclusive access
      BidTypeIgnore    BidType = "ignore"     // No interest
  )

  // Bid represents a single agent's bid on a claim
  // Note: In Redis, bids are stored as a hash where key=agent_name, value=bid_type
  // This struct is for in-memory representation
  type Bid struct {
      AgentName string  `json:"agent_name"`
      BidType   BidType `json:"bid_type"`
  }
  ```

* **Redis key patterns** (defined as helper functions):

  ```go
  // Instance-specific key helpers
  func ArtefactKey(instanceName, artefactID string) string
  func ClaimKey(instanceName, claimID string) string
  func ClaimBidsKey(instanceName, claimID string) string
  func ThreadKey(instanceName, logicalID string) string

  // Example outputs:
  // "holt:default-1:artefact:550e8400-e29b-41d4-a716-446655440000"
  // "holt:default-1:claim:550e8400-e29b-41d4-a716-446655440000"
  // "holt:default-1:claim:550e8400-e29b-41d4-a716-446655440000:bids"
  // "holt:default-1:thread:550e8400-e29b-41d4-a716-446655440000"
  ```

* **Thread tracking** (Redis ZSET structure):

  ```go
  // Thread tracking uses a Redis ZSET with the following structure:
  // - Key: holt:{instance_name}:thread:{logical_id}
  // - Members: artefact IDs
  // - Score: The artefact's version number, converted to a float64.

  // Helper struct for representing a version in a thread.
  // This is used by the client and not implemented as a function in M1.1.
  type ThreadVersion struct {
      ArtefactID string
      Version    int
  }
  ```

* **New Pub/Sub channels:**

  ```go
  // Channel name constants and helpers

  func ArtefactEventsChannel(instanceName string) string
  func ClaimEventsChannel(instanceName string) string

  // Example outputs:
  // "holt:default:artefact_events"
  // "holt:default:claim_events"
  ```

### **2.2. Orchestrator changes**

* **New/modified logic:**
  No changes to orchestrator in this milestone. The orchestrator will import and use these types in M1.5.

* **New/modified configurations (holt.yml):**
  No changes to holt.yml in this milestone.

### **2.3. Agent pup changes**

* **New/modified logic:**
  No changes to pup in this milestone. The pup will import and use these types in Phase 2.

* **Changes to the tool execution contract (stdin/stdout):**
  No changes in this milestone. The contract definition will use these types but isn't implemented yet.

### **2.4. CLI changes**

* **New/modified commands:**
  No changes to CLI commands in this milestone. The CLI will import and use these types starting in M1.3.

* **Changes to user output:**
  No changes to user-facing output in this milestone.

## **3. The 'how': implementation & testing plan**

### **3.1. Key design decisions & risks**

**Decision 1: Public package (`pkg/blackboard`) vs internal package**

* **Rationale**: This is the shared contract between all components (orchestrator, pup, CLI). Making it public in `pkg/` follows Go conventions for shared libraries and clearly signals this is a stable API.
* **Risk**: Public APIs are harder to change. Mitigation: Careful design review before implementation.

**Decision 2: Redis Hash fields vs JSON blob storage**

* **Rationale**: Store each struct field as a separate Redis hash field for better queryability and atomic updates. Arrays (like `source_artefacts`) get JSON-encoded into a single field.
* **Risk**: Mixed storage approach (some fields direct, some JSON) could be confusing. Mitigation: Clear documentation and helper functions abstract the complexity.

**Decision 3: Strong typing with enums vs string constants**

* **Rationale**: Use Go type aliases (`type StructuralType string`) with const definitions for type safety while maintaining JSON serialization compatibility.
* **Risk**: None significant - this is idiomatic Go.

**Decision 4: Validation methods on types**

* **Rationale**: Each type gets a `Validate() error` method to catch malformed data before it reaches Redis.
* **Risk**: Validation logic could drift from actual usage. Mitigation: Comprehensive unit tests.

**Decision 5: No smart constructors (yet)**

* **Rationale**: For V1, keep it simple - exported fields with manual initialization. Add builder pattern in future if needed.
* **Risk**: Developers might create invalid instances. Mitigation: Validation methods and good documentation.

### **3.2. Implementation steps**

**Step 1: Package structure and core types**
- [ ] Create `pkg/blackboard/` directory
- [ ] Define `types.go` with Artefact, Claim, Bid structs
- [ ] Define enum types (StructuralType, ClaimStatus, BidType) with constants
- [ ] Add struct field tags for JSON serialization

**Step 2: Validation methods**
- [ ] Implement `Artefact.Validate() error`
  - Check ID is valid UUID
  - Check LogicalID is valid UUID
  - Check Version >= 1
  - Check StructuralType is valid enum value
  - Check Type is non-empty
  - Check ProducedByRole is non-empty
  - Check SourceArtefacts are valid UUIDs
- [ ] Implement `Claim.Validate() error`
  - Check ID is valid UUID
  - Check ArtefactID is valid UUID
  - Check Status is valid enum value
  - Validate agent name arrays are not malformed
- [ ] Implement `BidType.Validate() error`
  - Check value is one of the valid bid types
- [ ] Add helper function `IsValidUUID(s string) bool`

**Step 3: Redis key patterns**
- [ ] Create `schema.go` for Redis key helpers
- [ ] Implement `ArtefactKey(instanceName, artefactID string) string`
- [ ] Implement `ClaimKey(instanceName, claimID string) string`
- [ ] Implement `ClaimBidsKey(instanceName, claimID string) string`
- [ ] Implement `ThreadKey(instanceName, logicalID string) string`
- [ ] Add key parsing helpers (extract UUID from key if needed)

**Step 4: Serialization helpers**
- [ ] Create `serialization.go` for conversion helpers
- [ ] Implement `ArtefactToHash(a *Artefact) (map[string]interface{}, error)`
- [ ] Implement `HashToArtefact(hash map[string]string) (*Artefact, error)`
- [ ] Implement `ClaimToHash(c *Claim) (map[string]interface{}, error)`
- [ ] Implement `HashToClaim(hash map[string]string) (*Claim, error)`
- [ ] Handle JSON encoding/decoding of array fields

**Step 5: Thread tracking utilities**
- [ ] Create `thread.go` for thread-related types and helpers
- [ ] Implement `ThreadVersion` struct
- [ ] Implement `ThreadScore(version int) float64` (converts version to ZSET score)
- [ ] Implement `VersionFromScore(score float64) int`

**Step 6: Pub/Sub channel helpers**
- [ ] Implement `ArtefactEventsChannel()` and `ClaimEventsChannel()` helper functions in `schema.go`

**Step 7: Documentation**
- [ ] Add package-level godoc comment explaining the blackboard
- [ ] Document all exported types and functions
- [ ] Add examples in godoc format

**Step 8: Testing**
- [ ] Write unit tests (see section 3.4)

### **3.3. Performance & resource considerations**

* **Resource usage:**
  - This is a pure Go library with no runtime resources
  - Memory: Negligible (only type definitions)
  - CPU: Minimal (validation and serialization are simple operations)
  - No network or storage impact at this layer

* **Scalability limits:**
  - No scalability limits - this is foundational code
  - JSON encoding of large arrays (source_artefacts) could be slow, but realistic array sizes (< 100 items) are fine

* **Performance requirements:**
  - Validation methods should complete in < 1ms (trivial for V1 scope)
  - Serialization/deserialization should complete in < 5ms
  - No performance bottlenecks expected

### **3.4. Testing strategy**

* **Unit tests:**

  **File: `pkg/blackboard/types_test.go`**
  - Test `Artefact.Validate()` with valid artefacts (pass)
  - Test `Artefact.Validate()` with invalid UUIDs (fail)
  - Test `Artefact.Validate()` with invalid StructuralType (fail)
  - Test `Artefact.Validate()` with empty required fields (fail)
  - Test `Claim.Validate()` with valid claims (pass)
  - Test `Claim.Validate()` with invalid status (fail)
  - Test `BidType.Validate()` with all valid values (pass)
  - Test `BidType.Validate()` with invalid value (fail)

  **File: `pkg/blackboard/schema_test.go`**
  - Test `ArtefactKey()` returns correct format
  - Test `ClaimKey()` returns correct format
  - Test `ClaimBidsKey()` returns correct format with `:bids` suffix
  - Test `ThreadKey()` returns correct format
  - Test `ArtefactEventsChannel()` returns namespaced channel name
  - Test `ClaimEventsChannel()` returns namespaced channel name
  - Test instance name namespacing works correctly for all keys and channels

  **File: `pkg/blackboard/serialization_test.go`**
  - Test `ArtefactToHash()` then `HashToArtefact()` round-trip (perfect fidelity)
  - Test `ClaimToHash()` then `HashToClaim()` round-trip (perfect fidelity)
  - Test array fields (source_artefacts) serialize correctly to JSON
  - Test empty arrays serialize correctly
  - Test malformed JSON in hash fails deserialization gracefully

  **File: `pkg/blackboard/thread_test.go`**
  - Test `ThreadScore()` converts version to float64
  - Test `VersionFromScore()` converts back correctly
  - Test thread key generation

* **Integration tests:**
  Not applicable - no Redis interaction in this milestone.

* **Performance tests:**
  Not needed for V1 - operations are trivial.

* **E2E tests:**
  Not applicable - this is a library with no user-facing behavior.

## **4. Principle compliance check**

### **4.1. YAGNI (You Ain't Gonna Need It)**

**New dependencies:**
- `github.com/google/uuid` - For UUID validation and generation

**Justification:**
- UUID handling is core to the blackboard schema. Using the standard, well-tested `google/uuid` library is more pragmatic than writing our own validation.
- No other external dependencies needed - using only Go standard library otherwise.

**YAGNI applied:**
- NOT adding builder pattern (can add later if needed)
- NOT adding complex query/filter logic (not needed yet)
- NOT adding schema versioning/migration (V1 assumes clean slate)

### **4.2. Auditability**

This milestone defines the immutable Artefact structure that is the foundation of auditability:
- `Artefact` struct enforces immutability through documentation and validation
- `SourceArtefacts` array creates the DAG for full provenance tracking
- `ProducedByRole` ensures attribution of all artefacts
- `Version` and `LogicalID` enable complete change history tracking

All significant state is represented as artefacts, satisfying the auditability principle.

### **4.3. Small, single-purpose components**

This milestone creates a focused, single-purpose package:
- **Purpose**: Define blackboard data structures and Redis schema
- **Scope**: Type definitions, validation, serialization helpers only
- **NOT included**: Redis client, Pub/Sub logic, CRUD operations (those are M1.2)

Clear separation of concerns maintained.

### **4.4. Security considerations**

* **Attack surfaces:**
  - Input validation prevents malformed data from reaching Redis (UUIDs, enums)
  - No direct security implications at this layer

* **Data exposure:**
  - Artefact payloads are opaque strings - no sensitive data handling at this layer
  - No encryption defined (assume Redis network is secure for V1)

* **Container isolation:**
  - Not applicable - this is a Go library

* **Network security:**
  - Not applicable - no network communication at this layer

**Security note**: This foundation enables future security features (encryption, signing) through the artefact payload mechanism.

### **4.5. Backward compatibility**

* **Breaking changes:**
  - This is the initial implementation - no backward compatibility concerns
  - Future schema changes will be breaking by nature

* **Migration path:**
  - For V1: Clean slate assumption (no existing data to migrate)
  - Future: Schema version field could be added to types

* **Additive design:**
  - New structural types can be added to enum without breaking existing code
  - New claim statuses can be added similarly
  - New fields can be added to structs if they're optional

**Compatibility note**: This schema will be the foundation - changes must be carefully considered.

### **4.6. Dependency impact**

* **Redis requirements:**
  - No specific Redis version requirements beyond basic Hash and ZSET support (Redis 2.0+)
  - No Redis modules required

* **Go version:**
  - Requires Go 1.22+ (for modern generics and error handling)

* **Build dependencies:**
  - `github.com/google/uuid` - stable, widely used, no concerns

* **Development environment:**
  - No impact - pure Go code with standard testing

**Dependency note**: Minimal, stable dependencies maintain the YAGNI principle.

## **5. Definition of done**

*This checklist must be fully satisfied for the milestone to be considered complete.*

* [ ] All implementation steps from section 3.2 are complete
* [ ] All tests defined in section 3.4 are implemented and passing
* [ ] Test coverage for `pkg/blackboard` is >= 90%
* [ ] All exported types have godoc comments
* [ ] Package-level documentation explains the blackboard concept
* [ ] `go vet` and `golint` pass with no warnings
* [ ] All validation methods correctly reject invalid data
* [ ] Round-trip serialization tests pass with 100% fidelity
* [ ] Redis key generation follows documented patterns
* [ ] UUID validation works correctly
* [ ] Enum validation catches invalid values
* [ ] Code review completed (if human developer)
* [ ] No TODOs or FIXMEs remain in code
* [ ] Integration with M1.2 interfaces considered and documented

## **6. Error scenarios & edge cases**

### **6.1. Failure modes**

**Failure: Invalid UUID in artefact or claim**
- **Detection**: `Validate()` method checks UUID format
- **Response**: Return descriptive error (e.g., "invalid artefact ID: not a valid UUID")
- **Recovery**: Caller must fix UUID before retry

**Failure: Invalid enum value (StructuralType, ClaimStatus, BidType)**
- **Detection**: `Validate()` method checks against known constants
- **Response**: Return descriptive error (e.g., "invalid structural type: 'Invalid'")
- **Recovery**: Caller must use valid enum value

**Failure: Empty required field**
- **Detection**: `Validate()` method checks for empty strings
- **Response**: Return descriptive error (e.g., "artefact type cannot be empty")
- **Recovery**: Caller must provide required field

**Failure: JSON serialization error for arrays**
- **Detection**: `ArtefactToHash()` or `HashToArtefact()` catches JSON error
- **Response**: Return wrapped error with context
- **Recovery**: Caller must fix malformed array data

**Failure: Malformed source_artefacts array (non-UUID values)**
- **Detection**: `Validate()` checks each UUID in array
- **Response**: Return error identifying which element is invalid
- **Recovery**: Caller must fix invalid UUID in array

### **6.2. Concurrency considerations**

* **Thread safety**: All types are simple structs with no internal state - safe for concurrent reads
* **Mutable state**: No shared mutable state in this package
* **Race conditions**: Not applicable - this is a pure library with no goroutines

**Note**: Redis-level concurrency will be handled in M1.2 (client operations).

### **6.3. Edge case handling**

**Edge case: Version number of 0**
- **Handling**: Validation rejects version < 1 (versions start at 1)
- **Rationale**: Version 0 is semantically meaningless

**Edge case: LogicalID same as ID (first version)**
- **Handling**: Allowed and expected for version 1 of any thread
- **Validation**: No special check needed

**Edge case: Empty source_artefacts array**
- **Handling**: Allowed - root artefacts have no sources
- **Validation**: Empty array is valid

**Edge case: Very long payload strings**
- **Handling**: No length limit enforced at this layer
- **Rationale**: Redis can handle large values; we'll add limits in M1.2 if needed

**Edge case: Special characters in instance name**
- **Handling**: No validation in V1 - assume valid instance names from CLI
- **Future**: Add instance name format validation if needed

**Edge case: Nil slices vs empty slices**
- **Handling**: Serialize both as empty JSON array `[]`
- **Deserialization**: Always create empty slice, never nil

## **7. Open questions & decisions**

**Q1: Should we add a CreatedAt timestamp to artefacts?**
- **Decision**: NO for V1. Redis can track key creation time if needed. YAGNI principle.
- **Rationale**: Not required for Phase 1 success criteria; can add later if needed

**Q2: Should validation methods be pointer receivers or value receivers?**
- **Decision**: Pointer receivers `(*Artefact) Validate()` for consistency with idiomatic Go
- **Rationale**: Even though we don't mutate, pointer receivers are conventional for struct methods

**Q3: Should we validate that structural types align with content?**
- **Decision**: NO - too complex for this layer. Example: Don't validate that Review artefacts have JSON payloads.
- **Rationale**: Content validation is agent/orchestrator responsibility, not schema responsibility

**Q4: Should we add helper constructors like `NewArtefact()`?**
- **Decision**: NOT in M1.1. May add in future if patterns emerge.
- **Rationale**: YAGNI - let usage patterns emerge first

**Q5: How should we handle forward compatibility (new enum values added later)?**
- **Decision**: Validation will reject unknown enum values in V1. Future versions can add "unknown" handling if needed.
- **Rationale**: Fail-fast is safer than allowing unknown states

**✅ All questions resolved** - ready for implementation.

## **8. AI agent implementation guidance**

### **8.1. Development approach**

**Start with the simplest path:**
1. Define types in `types.go` first (most critical)
2. Add validation methods (catch errors early)
3. Add key helpers in `schema.go` (simple string formatting)
4. Add serialization in `serialization.go` (most complex)
5. Add thread utilities last (simple math conversions)

**Write tests first (TDD approach):**
- Start with validation tests - they're simplest and define behavior
- Then test key generation - easy to verify
- Then test serialization round-trips - most important for correctness
- Red-Green-Refactor cycle for each function

**Defensive programming:**
- Always validate UUIDs before using them
- Handle nil slices explicitly (convert to empty)
- Return wrapped errors with context (e.g., `fmt.Errorf("invalid artefact: %w", err)`)

### **8.2. Common pitfalls to avoid**

❌ **Pitfall**: Forgetting to validate array elements (source_artefacts UUIDs)
✅ **Solution**: Loop through array in validation method

❌ **Pitfall**: JSON encoding nil slices as `null` instead of `[]`
✅ **Solution**: Initialize empty slices in deserialization

❌ **Pitfall**: Not handling JSON decode errors gracefully
✅ **Solution**: Wrap errors with context about which field failed

❌ **Pitfall**: Using value receivers for validation methods (inconsistent)
✅ **Solution**: Use pointer receivers for all methods

❌ **Pitfall**: Hardcoding instance names in key functions
✅ **Solution**: Always pass instance name as parameter

❌ **Pitfall**: Forgetting to export types/functions that other packages need
✅ **Solution**: Follow Go naming conventions (capitalized = exported)

### **8.3. Integration checklist**

**Pre-implementation verification:**
* [x] All prerequisite features are complete (none - this is first milestone)
* [x] No breaking changes to existing contracts (no existing contracts)
* [x] New data structures are backward compatible (initial implementation)
* [x] All component interfaces remain stable (no interfaces yet)

**Post-implementation verification:**
* [ ] M1.2 can import this package without circular dependencies
* [ ] M1.5 (orchestrator) can use these types
* [ ] M1.6 (CLI forage) can create artefacts with these types
* [ ] No changes needed to system specification documents

## **9. Operational readiness**

### **9.1. Monitoring and observability**

**Metrics:** Not applicable - this is a library with no runtime behavior

**Logging:** Not applicable - validation errors are returned to caller, not logged

**Health checks:** Not applicable - no persistent processes or connections

**Diagnostics:** Clear error messages from validation methods enable debugging

### **9.2. Rollback and disaster recovery**

**Feature flag:** Not applicable - this is a library

**Rollback procedure:** If types are wrong, fix and recompile. No runtime rollback needed.

**Data migration:** Not applicable for V1 (clean slate assumption)

**Recovery time:** Immediate (compilation + restart of dependent binaries)

### **9.3. Documentation and training**

**CLI documentation:** Not applicable - no CLI commands

**API documentation:**
- [ ] Godoc comments on all exported types and functions
- [ ] Package-level example showing typical usage
- [ ] README in `pkg/blackboard/` with quick start

**Troubleshooting:**
- Error messages from `Validate()` methods are self-explanatory
- No special troubleshooting guide needed

**Training needs:** None - standard Go development practices

## **10. Self-validation checklist**

### **Before starting implementation:**

* [x] I understand how this feature aligns with the current phase (Phase 1 - Foundation)
* [x] All success criteria (section 1.3) are measurable and testable
* [x] I have considered every component in section 2 explicitly
* [x] All design decisions (section 3.1) are justified and documented

### **During implementation:**

* [ ] I am implementing the simplest solution that meets success criteria
* [ ] All error scenarios (section 6) are being handled, not just happy path
* [ ] Tests are being written before or alongside code (TDD approach)
* [ ] I am validating that no breaking changes are introduced

### **Before submission:**

* [ ] All items in Definition of Done (section 5) are complete
* [ ] Feature has been tested with comprehensive unit tests
* [ ] Documentation is updated and accurate (godoc)
* [ ] No TODOs or placeholder code remains
* [ ] Code follows Go conventions and passes `go vet`
* [ ] Test coverage is >= 90% for the package
