# **Feature design: M2.4 - Context Assembly & Git Integration**

**Purpose**: Implement context assembly with BFS graph traversal and git commit hash validation
**Scope**: Agent cub context assembly, thread tracking, git integration, filtered context chain
**Estimated tokens**: ~8,500 tokens

Associated phase: **Single Agent (Phase 2)**
Status: **Draft**

***Template purpose:*** *This document is a blueprint for a single, implementable milestone. Its purpose is to provide an unambiguous specification for a developer (human or AI) to build a feature that is consistent with Sett's architecture and guiding principles.*

## **1. The 'why': goal and success criteria**

### **1.1. Goal statement**

Implement the context assembly algorithm to provide agents with rich historical context via breadth-first graph traversal with thread tracking, and enable git commit hash validation for code artefacts.

### **1.2. User story**

As a Sett developer, I need agents to receive complete historical context when executing work, so that LLM-driven agents can make informed decisions based on the full chain of previous work, and code-generating agents can produce git commits that are properly validated.

### **1.3. Success criteria**

**Context Assembly:**
* Context assembly algorithm correctly traverses the artefact graph via BFS
* For each `logical_id` encountered, the algorithm fetches the latest version from thread tracking (ZSET)
* Traversal respects the 10-level depth limit safety valve
* De-duplication prevents the same `logical_id` from appearing multiple times
* Final `context_chain` is ordered chronologically (oldest → newest)
* Final `context_chain` contains only `Standard` and `Answer` artefacts (filtered)
* Empty context_chain (`[]`) is handled correctly for root artefacts

**Git Integration:**
* When tool output has `artefact_type: "CodeCommit"`, cub validates the commit hash exists
* Validation uses `git cat-file -e <commit-hash>` to check commit existence
* If commit doesn't exist, cub creates Failure artefact with descriptive error
* Valid commits are accepted and artefact created normally
* Non-CodeCommit artefacts skip git validation entirely

**E2E Workflow:**
* Agent receives claim with multi-level source chain
* Context assembly builds correct context from graph
* Tool receives filtered, chronologically-ordered context via stdin
* Tool can produce CodeCommit artefact with valid git hash
* New artefact becomes part of graph for future context assembly

**Validation questions:**
* ✅ Can each success criterion be automated as a test? Yes - integration tests with mock artefact graphs
* ✅ Does each criterion represent user-visible value? Yes - agents get context, git commits validated
* ✅ Are the criteria specific enough to avoid ambiguity? Yes - algorithm steps defined, git validation explicit

### **1.4. Non-goals**

* **NOT in scope**: Git branching strategy - agents commit to current branch (Phase 3 multi-agent concern)
* **NOT in scope**: Workspace state management - pre-flight check in `sett up` command
* **NOT in scope**: Git checkout/stash operations - agent script responsibility
* **NOT in scope**: Commit message template enforcement - agent script responsibility (but documented)
* **NOT in scope**: Review or parallel claim types (Phase 3) - only exclusive claims
* **NOT in scope**: Question/Answer artefact creation (Phase 4) - only Standard and Failure
* **NOT in scope**: Loop detection beyond depth limit - V1 uses hard limit
* **NOT in scope**: Context size optimization - include all Standard/Answer artefacts found

## **2. The 'what': component impact analysis**

**Critical validation questions for this entire section:**
* ✅ Have I explicitly considered EVERY component (Blackboard, Orchestrator, Cub, CLI)?
* ✅ For components marked "No changes" - am I absolutely certain this feature doesn't affect them?
* ✅ Do my changes maintain the contracts and interfaces defined in the design documents?
* ✅ Will this feature work correctly with both single-instance and scaled agents (controller-worker pattern)?

### **2.1. Blackboard changes**

**New/modified data structures:** No changes to schemas

**Required operations (already supported):**
- `GetArtefact(ctx, artefactID)` - fetch artefacts during graph traversal
- `GetLatestVersion(ctx, logicalID)` - query thread ZSET for latest version
- Thread tracking already implemented in M1.2

**Rationale:** All required blackboard operations exist. M2.4 is the first milestone to USE thread tracking for context assembly.

### **2.2. Orchestrator changes**

**New/modified logic:** No changes

**Rationale:** Orchestrator creates claims and publishes events. Context assembly is entirely cub-side.

### **2.3. Agent cub changes**

**New/modified logic:**

1. **Context Assembly Implementation (MAJOR CHANGE):**
   - Replace hardcoded `context_chain: []` in M2.3 with real algorithm
   - Implement BFS traversal of `source_artefacts` graph
   - Implement thread tracking lookup for each `logical_id`
   - Implement de-duplication via map keyed by `logical_id`
   - Implement chronological sorting (oldest → newest)
   - Implement filtering to Standard/Answer only
   - Add 10-level depth limit safety valve

2. **Context Assembly Algorithm (from agent-cub.md):**
   ```
   Algorithm:
   1. Start traversal: Begin with target artefact's source_artefacts
   2. Initialize: Create BFS queue and context map (keyed by logical_id)
   3. Walk graph (BFS):
      - For each artefact ID in queue (max 10 levels):
        a. Fetch artefact from blackboard
        b. Use GetLatestVersion(logical_id) to find latest in thread
        c. Add latest version to context map (de-duplicates by logical_id)
        d. Add all source_artefacts to queue for next level
   4. Filter: Remove non-Standard, non-Answer artefacts from map
   5. Sort: Order by created_at timestamp (oldest → newest)
   6. Return: Array of filtered, sorted artefacts
   ```

3. **Thread Tracking Integration:**
   - For each artefact encountered during traversal:
   - Query `GetLatestVersion(ctx, artefact.LogicalID)`
   - Replace the discovered artefact with the latest version
   - This ensures context always shows the most recent state

4. **Git Commit Validation (NEW):**
   - After tool execution, check if `output.ArtefactType == "CodeCommit"`
   - If yes, validate commit hash:
     ```go
     cmd := exec.Command("git", "cat-file", "-e", commitHash)
     cmd.Dir = "/workspace"
     if err := cmd.Run(); err != nil {
         // Commit doesn't exist - create Failure artefact
     }
     ```
   - If validation fails, create Failure artefact with error details
   - If validation passes, create artefact normally

5. **Updated Tool Input Structure:**
   - `ToolInput.ContextChain` now populated with filtered artefacts
   - Each artefact in chain is full `blackboard.Artefact` object
   - Chain ordered chronologically (oldest first)

**New files:**
- `internal/cub/context.go` - Context assembly implementation
- `internal/cub/context_test.go` - Unit tests for assembly algorithm
- `internal/cub/git.go` - Git validation helpers
- `internal/cub/git_test.go` - Git validation tests

**Modified files:**
- `internal/cub/executor.go` - Call context assembly, validate git commits
- `internal/cub/contract.go` - Document context_chain population

### **2.4. CLI changes**

**New/modified commands:** No changes

**Documentation updates:**
- Update example agent README with context chain examples
- Document recommended commit message format (not enforced by cub)

**Rationale:** Context assembly is purely cub-side. CLI only needs documentation updates.

## **3. The 'how': implementation & testing plan**

### **3.1. Key design decisions & risks**

**Key design decisions:**

1. **BFS vs DFS for Graph Traversal:**
   - **Decision:** Use Breadth-First Search (BFS)
   - **Rationale:** BFS ensures we see "nearby" context first (immediate ancestors before distant ones)
   - **Implementation:** Use Go slice as queue, append to end, pop from front
   - **Alternative rejected:** DFS (depth-first) would give unbalanced context

2. **Thread Tracking Strategy:**
   - **Decision:** For EVERY artefact discovered, look up latest version via GetLatestVersion()
   - **Rationale:** Ensures context shows current state, not stale versions
   - **Performance:** Acceptable for V1 (10-level limit means max ~100 artefacts)
   - **Future optimization:** Cache thread lookups if performance becomes issue

3. **De-duplication Key:**
   - **Decision:** Use `logical_id` as map key for de-duplication
   - **Rationale:** Multiple source chains may reference same logical artefact
   - **Benefit:** Context contains each logical entity exactly once (latest version)

4. **Context Filtering Timing:**
   - **Decision:** Filter AFTER traversal and thread tracking, BEFORE sorting
   - **Rationale:** Must traverse all artefacts to build correct graph, but only show actionable ones
   - **Two-step process:** (1) Traverse all including Failure/Review, (2) Filter to Standard/Answer only

5. **Chronological Ordering:**
   - **Decision:** Sort by `created_at` timestamp, oldest first
   - **Rationale:** Agents read context like a story (beginning → present)
   - **Implementation:** `sort.Slice()` on filtered artefacts

6. **Depth Limit Safety Valve:**
   - **Decision:** Hard limit of 10 levels, no loop detection
   - **Rationale:** YAGNI - simple depth check is sufficient for V1
   - **Risk mitigation:** Prevents infinite loops in malformed graphs
   - **Future enhancement:** Track visited IDs for robust loop detection

7. **Git Validation Scope:**
   - **Decision:** Only validate `CodeCommit` artefact type
   - **Rationale:** Only code artefacts have git commit hash payloads
   - **Performance:** Single `git cat-file -e` call is fast (<10ms)
   - **Alternative rejected:** Validate all artefacts (many aren't git-related)

8. **Git Validation Timing:**
   - **Decision:** Validate AFTER tool execution, BEFORE artefact creation
   - **Rationale:** Fail fast if commit doesn't exist
   - **Benefit:** Prevents invalid artefacts from polluting blackboard

9. **No Workspace Management:**
   - **Decision:** Cub does NOT check workspace state, checkout commits, or manage branches
   - **Rationale:** Pre-flight check in `sett up`, agent script manages git
   - **Separation of concerns:** Cub executes and validates, script manages workspace

10. **Commit Message Format (Documentation Only):**
    - **Decision:** Document recommended format, do NOT enforce in cub
    - **Rationale:** Agent script responsibility, cub doesn't parse commits
    - **Format:** `[sett-agent: {role}] {summary}\n\nClaim-ID: {claim-id}`

**Potential risks:**

* **Risk:** Large context chains exceed memory limits
  * **Mitigation:** 10-level depth limit caps total artefacts
  * **Monitoring:** Log context chain size in bytes
  * **Future:** Add size limit (e.g., 1MB total context)

* **Risk:** GetLatestVersion() calls slow down traversal
  * **Mitigation:** Acceptable for V1 (max ~100 calls)
  * **Future:** Batch fetch or cache thread lookups

* **Risk:** Circular references in source_artefacts graph
  * **Mitigation:** 10-level depth limit prevents infinite loops
  * **Detection:** Log warning if depth limit hit
  * **Future:** Track visited IDs explicitly

* **Risk:** Git validation fails for valid commits (race condition)
  * **Mitigation:** Agent script commits before returning hash
  * **Testing:** Verify git operations are synchronous
  * **Retry:** No retry - single validation attempt

* **Risk:** Context filtering removes all artefacts (only Failures in chain)
  * **Mitigation:** Empty context_chain (`[]`) is valid - agent handles it
  * **Documentation:** Tool must handle empty context gracefully

**Alignment with Sett's architectural principles:**
* **Auditability:** ✅ Full graph traversal captures complete provenance
* **YAGNI:** ✅ No complex loop detection, no branch management, no retry logic
* **Immutability:** ✅ Context assembly reads only, doesn't modify artefacts
* **Event-driven:** ✅ No changes to event model, context assembled on-demand

### **3.2. Implementation steps**

**Phase 1: Context Assembly Core**

1. **[Cub]** Create `internal/cub/context.go`:
   - Define `assembleContext(ctx, targetArtefact, bbClient)` function
   - Implement BFS queue using Go slice
   - Implement visited map keyed by `logical_id`
   - Add depth counter, max 10 levels

2. **[Cub]** Implement BFS traversal loop:
   - Initialize queue with `targetArtefact.SourceArtefacts`
   - For each level (max 10):
     - For each artefact ID in current level:
       - Fetch artefact via `GetArtefact(ctx, id)`
       - Call `GetLatestVersion(ctx, artefact.LogicalID)`
       - Store latest version in context map
       - Add source_artefacts to next level queue

3. **[Cub]** Implement filtering and sorting:
   - Filter map to include only `Standard` and `Answer` structural types
   - Convert map to slice of artefacts
   - Sort slice by `created_at` timestamp (oldest first)
   - Return sorted slice

4. **[Cub]** Add unit tests for context assembly:
   - Test with linear chain (A → B → C)
   - Test with branching (A → [B, C] → D)
   - Test with thread evolution (v1 → v2 → v3, should return v3)
   - Test with depth limit (11-level chain, should cap at 10)
   - Test with filtering (include Failure, should be removed)
   - Test with empty source_artefacts (should return empty array)

**Phase 2: Git Validation**

5. **[Cub]** Create `internal/cub/git.go`:
   - Define `validateCommitExists(commitHash string) error` function
   - Use `exec.Command("git", "cat-file", "-e", commitHash)`
   - Set working directory to `/workspace`
   - Return error if command fails

6. **[Cub]** Add unit tests for git validation:
   - Test with valid commit hash (requires git repo setup)
   - Test with invalid commit hash (should return error)
   - Test with malformed hash (should return error)

**Phase 3: Integration into Executor**

7. **[Cub]** Update `executor.go::prepareToolInput()`:
   - Call `assembleContext(ctx, targetArtefact, e.bbClient)`
   - Replace hardcoded `ContextChain: []interface{}{}` with result
   - Handle empty context (valid case)
   - Log context chain size for monitoring

8. **[Cub]** Update `executor.go::createResultArtefact()`:
   - After parsing ToolOutput, check if `output.ArtefactType == "CodeCommit"`
   - If yes, call `validateCommitExists(output.ArtefactPayload)`
   - If validation fails, return error (triggers Failure artefact)
   - If validation passes, proceed with artefact creation

9. **[Cub]** Update failure handling for git validation:
   - Create Failure artefact with reason: "Git commit validation failed"
   - Include commit hash in failure payload
   - Include git error message in payload

**Phase 4: Integration Tests**

10. **[Cub]** Create `internal/cub/context_integration_test.go`:
    - Start Redis via testcontainers
    - Create multi-level artefact graph in Redis
    - Create thread tracking entries with multiple versions
    - Call `assembleContext()` with target artefact
    - Verify correct artefacts returned in chronological order
    - Verify latest versions selected from threads
    - Verify filtering removes non-Standard/Answer artefacts

11. **[Cub]** Create git validation integration test:
    - Initialize git repo in temp directory
    - Create commit with known hash
    - Set `/workspace` to temp directory (or mock)
    - Call `validateCommitExists()` with valid hash
    - Verify success
    - Call with invalid hash, verify error

12. **[Cub]** Create executor integration test with context:
    - Create artefact chain: GoalDefined → DesignSpec → CodeCommit
    - Create claim for CodeCommit
    - Execute work (mock tool that returns valid output)
    - Verify tool received correct context_chain via stdin
    - Verify context includes GoalDefined and DesignSpec
    - Verify chronological order

**Phase 5: Example Agent Update**

13. **[Agent]** Update `agents/example-agent/run.sh`:
    - Add logic to parse and log `context_chain` from stdin
    - Demonstrate accessing context in shell script
    - Keep simple echo logic for core functionality

14. **[Agent]** Update `agents/example-agent/README.md`:
    - Document context_chain structure with example
    - Show how to access context in tool scripts
    - Document git commit hash validation
    - Document recommended commit message format

**Phase 6: Documentation**

15. **[Docs]** Update PROJECT_CONTEXT.md or README:
    - Document context assembly algorithm
    - Explain thread tracking usage
    - Document git validation feature
    - Document commit message format recommendation

16. **[Docs]** Create developer guide for agent scripts:
    - How to parse context_chain from stdin
    - How to perform git operations
    - How to return valid commit hashes
    - Example scripts in different languages

### **3.3. Performance & resource considerations**

**Resource usage:**
* **Memory:** Context assembly builds in-memory map, max ~100 artefacts × ~1KB each = ~100KB
* **CPU:** BFS traversal + sorting, complexity O(n log n), acceptable for n < 100
* **Redis:** GetArtefact() and GetLatestVersion() calls, max ~100 per execution
* **Git:** Single `git cat-file -e` call per CodeCommit, <10ms

**Scalability limits:**
* **Graph size:** 10-level depth limit caps total artefacts traversed
* **Context size:** Depends on artefact payload sizes, monitored via logs
* **Redis load:** ~100 reads per work execution (acceptable for V1)

**Performance requirements:**
* **Context assembly:** <500ms for typical 10-artefact chain
* **Git validation:** <50ms per commit
* **Total overhead:** <1 second added to work execution time

**Optimization opportunities (future):**
* Batch fetch artefacts in single Redis call
* Cache thread lookups for repeated logical_ids
* Implement context size limit (e.g., 1MB max)

### **3.4. Testing strategy**

**Unit tests:**

Location: `internal/cub/context_test.go`, `internal/cub/git_test.go`

1. **Context assembly algorithm (`context_test.go`):**
   - Test linear chain traversal (A → B → C)
   - Test branching graph (A → [B, C])
   - Test diamond pattern (A → [B, C] → D)
   - Test depth limit enforcement (11 levels → 10)
   - Test empty source_artefacts → empty context
   - Test de-duplication (same logical_id appears twice)
   - Test filtering (Failure artefacts removed)
   - Test chronological sorting

2. **Git validation (`git_test.go`):**
   - Test valid commit hash (requires temp git repo)
   - Test invalid commit hash returns error
   - Test malformed hash returns error
   - Test missing /workspace directory returns error

**Integration tests:**

Location: `internal/cub/context_integration_test.go`

1. **Context assembly with real Redis:**
   - Create multi-level artefact graph
   - Create thread tracking with multiple versions
   - Assemble context and verify:
     - Latest versions selected
     - Chronological order
     - Filtering applied
     - No duplicates

2. **Executor with context:**
   - Create artefact chain in Redis
   - Execute tool with context
   - Verify stdin contains correct context_chain
   - Verify tool can access context

3. **Git validation in executor:**
   - Create temp git repo with commit
   - Tool returns commit hash
   - Verify validation passes
   - Tool returns invalid hash
   - Verify Failure artefact created

**E2E tests:**

Location: `cmd/sett/commands/e2e_context_test.go`

1. **Full workflow with context:**
   - Create initial GoalDefined artefact
   - Agent creates DesignSpec (references GoalDefined)
   - Agent creates CodeCommit (references DesignSpec)
   - Verify each agent execution received correct context
   - Verify context grows with each iteration

**Test coverage target:** 85%+ for new/modified packages (context.go, git.go)

## **4. Principle compliance check**

### **4.1. YAGNI (You Ain't Gonna Need It)**

**New third-party dependencies:**
* None - uses standard library `os/exec`, existing blackboard client

**Justification:**
* No loop detection beyond depth limit (YAGNI)
* No context size optimization (wait for real-world data)
* No caching of thread lookups (premature optimization)
* No git branching logic (Phase 3 concern)
* No workspace management (pre-flight check responsibility)

### **4.2. Auditability**

**New artefacts created:**
* No new artefact types - uses existing Standard and Failure

**State changes captured:**
* Context assembly logged (artefact count, depth reached)
* Git validation logged (commit hash, validation result)
* Failure artefacts created for git validation failures

**Audit trail completeness:**
* Complete provenance via source_artefacts graph
* Thread tracking shows version evolution
* Context assembly reconstructable from graph

### **4.3. Small, single-purpose components**

**Component responsibility boundaries:**

* **Context Assembly:** Traverses graph, builds context - single responsibility
* **Git Validation:** Validates commit existence - single responsibility
* **Work Executor:** Orchestrates workflow - delegates to context + git modules

**No responsibility bleed:** Context assembly doesn't execute tools, git validation doesn't create artefacts.

### **4.4. Security considerations**

**Attack surfaces:**
* **Malicious commit hashes:** Git validation uses safe `git cat-file -e` (no shell injection)
  * **Mitigation:** exec.Command with args array (not shell string)
  * **Validation:** Commit hash format validation (future enhancement)

* **Malformed artefact graphs:** Circular references could cause issues
  * **Mitigation:** 10-level depth limit prevents infinite loops
  * **Future:** Explicit visited tracking for robust detection

**Data exposure risks:**
* **Context contains full artefact history:** Agents see all previous work
  * **Mitigation:** Expected behavior - agents need context to function
  * **Context:** All artefacts already visible to agent via blackboard access

**Git repository access:**
* Tool script has read/write access to /workspace
* Git validation only reads (cat-file -e)
* No workspace state changes by cub

### **4.5. Backward compatibility**

**API/data structure changes:**
* `ToolInput.ContextChain` now populated (was empty array in M2.3)
  * **Compatibility:** Tools expecting empty array still work
  * **Impact:** Tools can now access context (additive change)

**Existing workflows preserved:**
* M2.3 echo agent still works (ignores context)
* Artefact creation unchanged
* Blackboard schema unchanged

**Feature additive:** M2.4 enhances M2.3 without breaking existing functionality

### **4.6. Dependency impact**

**Go standard library usage:**
* `os/exec` - git validation (already used in M2.3)
* `sort` - context sorting (standard library)

**No new external dependencies**

**Blackboard client usage:**
* `GetArtefact()` - already implemented
* `GetLatestVersion()` - already implemented in M1.2

**Development environment impact:**
* Tests require git repository setup (already needed for project)
* No additional tools required

## **5. Definition of done**

*This checklist must be fully satisfied for the milestone to be considered complete.*

* [ ] All implementation steps from section 3.2 are complete
* [ ] All tests defined in section 3.4 are implemented and passing
* [ ] Performance requirements from section 3.3 are met and verified:
  * [ ] Context assembly <500ms for typical chain
  * [ ] Git validation <50ms per commit
* [ ] Overall test coverage has not decreased (project-wide)
* [ ] New/modified packages have 85%+ test coverage
* [ ] Context assembly correctly implements BFS traversal
* [ ] Thread tracking correctly retrieves latest version for each logical_id
* [ ] Context chain is chronologically ordered (oldest → newest)
* [ ] Context filtering removes all non-Standard/Non-Answer artefacts
* [ ] Depth limit (10 levels) is enforced and tested
* [ ] De-duplication prevents duplicate logical_ids in context
* [ ] Empty context_chain is handled correctly
* [ ] Git commit validation works for valid commits
* [ ] Git commit validation creates Failure for invalid commits
* [ ] Non-CodeCommit artefacts skip git validation
* [ ] Example agent demonstrates context usage
* [ ] Documentation updated with context assembly and git validation
* [ ] All TODOs from the specification documents relevant to this milestone have been resolved
* [ ] All failure modes identified in section 6.1 have been implemented and tested
* [ ] Concurrency considerations from section 6.2 have been addressed
* [ ] All open questions from section 7 have been resolved or documented as future work

## **6. Error scenarios & edge cases**

### **6.1. Failure modes**

**Context assembly failures:**

1. **GetArtefact() returns not found:**
   - **Scenario:** Source artefact ID doesn't exist in Redis
   - **Expected behavior:** Log warning, skip that artefact, continue traversal
   - **Work executor:** Create Failure artefact if context critical
   - **Testing:** Integration test with missing artefact ID

2. **GetLatestVersion() returns empty:**
   - **Scenario:** Thread tracking ZSET empty for logical_id
   - **Expected behavior:** Use the discovered artefact (no newer version)
   - **Work executor:** Continue with available artefact
   - **Testing:** Integration test with empty thread

3. **Depth limit reached:**
   - **Scenario:** Graph deeper than 10 levels
   - **Expected behavior:** Stop traversal, log warning, return partial context
   - **Work executor:** Tool receives partial context (valid)
   - **Testing:** Integration test with 11-level chain

4. **All artefacts filtered out:**
   - **Scenario:** Only Failure/Review artefacts in chain
   - **Expected behavior:** Return empty context_chain (`[]`)
   - **Work executor:** Tool must handle empty context gracefully
   - **Testing:** Integration test with only Failure artefacts

5. **Redis connection lost during traversal:**
   - **Scenario:** Network issue mid-traversal
   - **Expected behavior:** Return error from assembleContext()
   - **Work executor:** Create Failure artefact describing error
   - **Testing:** Mock Redis failure mid-traversal

**Git validation failures:**

6. **Commit hash doesn't exist:**
   - **Scenario:** Tool returns invalid commit hash
   - **Expected behavior:** `validateCommitExists()` returns error
   - **Work executor:** Create Failure artefact with error details
   - **Testing:** Integration test with invalid hash

7. **Git command fails (repo corrupted):**
   - **Scenario:** `git cat-file` fails for non-hash reason
   - **Expected behavior:** Return error with git stderr
   - **Work executor:** Create Failure artefact
   - **Testing:** Mock corrupted git repo

8. **Workspace not a git repository:**
   - **Scenario:** /workspace exists but no .git directory
   - **Expected behavior:** Git validation fails
   - **Work executor:** Create Failure artefact
   - **Note:** Should be caught by pre-flight check in `sett up`

**Combination failures:**

9. **Context assembly + git validation both needed:**
   - **Scenario:** CodeCommit artefact with complex context chain
   - **Expected behavior:** Both operations succeed independently
   - **Work executor:** Create artefact only if both succeed
   - **Testing:** E2E test with context + git validation

### **6.2. Concurrency considerations**

**Race conditions:**

1. **Artefact modified during traversal:**
   - **Scenario:** Artefact updated while assembling context
   - **Mitigation:** Context assembly is snapshot - uses discovered IDs
   - **Impact:** Context shows state at traversal time (acceptable)
   - **Testing:** No special testing - inherent to event-driven system

2. **Thread updated during GetLatestVersion():**
   - **Scenario:** New version added while querying thread
   - **Mitigation:** GetLatestVersion() is atomic Redis operation
   - **Impact:** Returns latest at query time (correct behavior)
   - **Testing:** No special testing - Redis handles atomicity

**Deadlock scenarios:**

3. **Circular references in graph:**
   - **Scenario:** A → B → C → A (malformed graph)
   - **Mitigation:** Depth limit prevents infinite loop
   - **Detection:** De-duplication map prevents revisiting
   - **Testing:** Integration test with circular graph

**Performance under concurrency:**

4. **Multiple agents traversing same graph:**
   - **Scenario:** Multiple agents reading same artefacts
   - **Mitigation:** Read operations don't block each other
   - **Impact:** Acceptable Redis read load
   - **Testing:** Load test with concurrent context assembly

### **6.3. Edge case handling**

**Empty or minimal contexts:**

1. **Root artefact (no source_artefacts):**
   - **Scenario:** Artefact with `source_artefacts: []`
   - **Expected behavior:** Return empty context_chain `[]`
   - **Testing:** Unit test with root artefact

2. **Single-level chain:**
   - **Scenario:** A → B (only one ancestor)
   - **Expected behavior:** Context contains only A
   - **Testing:** Unit test with single ancestor

**Large contexts:**

3. **Maximum-size context (depth 10, all branches):**
   - **Scenario:** Wide, deep graph at limit
   - **Expected behavior:** Traverse all within depth, return all Standard/Answer
   - **Performance:** Monitor memory and time
   - **Testing:** Integration test with max-size graph

4. **Large artefact payloads in context:**
   - **Scenario:** Context artefacts have 100KB+ payloads
   - **Expected behavior:** All included in context_chain
   - **Risk:** Large JSON in stdin
   - **Future:** Add total context size limit

**Artefact type variations:**

5. **Mixed structural types in chain:**
   - **Scenario:** Standard → Failure → Standard → Answer
   - **Expected behavior:** Filter to [Standard, Standard, Answer]
   - **Testing:** Integration test with mixed types

6. **Multiple versions in same chain:**
   - **Scenario:** A v1 → B → A v2 (newer version created)
   - **Expected behavior:** De-duplication keeps only A v2 (latest)
   - **Testing:** Integration test with version evolution

**Git edge cases:**

7. **Empty commit hash:**
   - **Scenario:** Tool returns `artefact_payload: ""`
   - **Expected behavior:** Git validation fails
   - **Work executor:** Create Failure artefact
   - **Testing:** Unit test with empty string

8. **Partial commit hash (short SHA):**
   - **Scenario:** Tool returns 7-char hash instead of 40
   - **Expected behavior:** Git validation accepts if unambiguous
   - **Git behavior:** `git cat-file -e` handles short hashes
   - **Testing:** Test with valid short hash

## **7. Open questions & decisions**

**Q1: Should we cache GetLatestVersion() results within a single context assembly?**
- **Question:** Same logical_id might appear multiple times in graph
- **Recommendation:** Yes - cache in local map during traversal
- **Benefit:** Reduces Redis calls from ~100 to ~50
- **Status:** ✅ Decided - implement caching in assembleContext()

**Q2: Should we validate commit hash format before calling git?**
- **Question:** Should we check hash is valid SHA-1 format?
- **Recommendation:** No - let git handle validation
- **Rationale:** YAGNI - git cat-file already validates
- **Status:** ✅ Decided - no format validation in M2.4

**Q3: Should empty context_chain cause work execution to abort?**
- **Question:** Is empty context an error condition?
- **Recommendation:** No - valid for root artefacts
- **Rationale:** Tool should handle context gracefully
- **Status:** ✅ Decided - empty context is valid

**Q4: Should we include Failure artefacts in context_chain?**
- **Question:** Can agents learn from previous failures?
- **Recommendation:** No - filter to Standard/Answer only
- **Rationale:** Keep context clean and actionable
- **Status:** ✅ Decided - filter out Failure/Review

**Q5: What if GetLatestVersion() returns a version older than discovered?**
- **Question:** Could thread tracking be stale?
- **Recommendation:** Use discovered version if thread returns older/empty
- **Rationale:** Defensive programming
- **Status:** ✅ Decided - take max(discovered, thread) version

**Q6: Should we validate that source_artefacts exist before traversing?**
- **Question:** Pre-validate all IDs before BFS?
- **Recommendation:** No - validate on-demand during traversal
- **Rationale:** Fail gracefully per artefact, not whole context
- **Status:** ✅ Decided - on-demand validation

## **8. AI agent implementation guidance**

### **8.1. Development approach**

**Start with the simplest path that satisfies success criteria:**

1. **BFS skeleton first:** Implement basic queue-based traversal without thread tracking
2. **Add thread tracking:** Integrate GetLatestVersion() calls
3. **Add filtering:** Implement Standard/Answer filter
4. **Add sorting:** Implement chronological ordering
5. **Git validation isolated:** Implement and test git validation separately
6. **Integrate together:** Wire context assembly into executor

**Implement comprehensive error handling from the beginning:**

* Every GetArtefact() call must handle not-found errors
* Every GetLatestVersion() call must handle empty results
* Every git validation must handle command failures
* All errors should be descriptive and include context (artefact ID, commit hash)

**Write tests before implementation (TDD approach):**

* Write BFS traversal test before implementing
* Write thread tracking test before integrating GetLatestVersion()
* Write filtering test before implementing filter
* Write git validation test before implementing

**Use defensive programming - validate all inputs and assumptions:**

* Check artefact not nil before accessing fields
* Check logical_id not empty before thread lookup
* Check commit hash not empty before git validation
* Handle empty source_artefacts gracefully

### **8.2. Common pitfalls to avoid**

**Forgetting thread tracking:**
* **Pitfall:** Using discovered artefact instead of latest version
* **Result:** Context shows stale state
* **Solution:** Always call GetLatestVersion() and use result

**Wrong sort direction:**
* **Pitfall:** Sorting newest → oldest instead of oldest → newest
* **Result:** Context reads backwards
* **Solution:** Sort by created_at ascending

**Not filtering before returning:**
* **Pitfall:** Returning all artefacts including Failure/Review
* **Result:** Polluted context
* **Solution:** Filter to Standard/Answer after traversal

**Forgetting de-duplication:**
* **Pitfall:** Using slice instead of map for storage
* **Result:** Duplicate logical_ids in context
* **Solution:** Use map keyed by logical_id

**Git validation for all artefacts:**
* **Pitfall:** Validating non-CodeCommit artefacts
* **Result:** Unnecessary git calls, false failures
* **Solution:** Check artefact_type == "CodeCommit" first

**Not handling empty context:**
* **Pitfall:** Treating empty context as error
* **Result:** Root artefacts fail to execute
* **Solution:** Empty slice is valid return value

**Depth limit off-by-one:**
* **Pitfall:** Implementing depth as "< 10" instead of "<= 10"
* **Result:** Only 9 levels traversed
* **Solution:** Clear depth counter logic in loop

### **8.3. Implementation checklist**

**Pre-implementation verification:**

* [ ] M2.3 is complete and all tests passing
* [ ] GetLatestVersion() exists in blackboard client (M1.2)
* [ ] Understanding of BFS algorithm is clear
* [ ] Understanding of thread tracking usage is clear

**Context assembly implementation:**

* [ ] BFS queue implemented with Go slice
* [ ] Context map keyed by logical_id for de-duplication
* [ ] Depth counter starts at 0, increments per level
* [ ] GetArtefact() called for each ID in queue
* [ ] GetLatestVersion() called for each logical_id
* [ ] Latest version stored in context map
* [ ] source_artefacts added to next level queue
* [ ] Filtering removes non-Standard/non-Answer
* [ ] Sorting by created_at oldest → newest
* [ ] Empty context (`[]`) handled correctly

**Git validation implementation:**

* [ ] validateCommitExists() checks artefact_type first
* [ ] git cat-file -e command constructed correctly
* [ ] Working directory set to /workspace
* [ ] Command errors captured and returned
* [ ] Success returns nil
* [ ] Failure includes descriptive error message

**Integration:**

* [ ] prepareToolInput() calls assembleContext()
* [ ] Context result assigned to ToolInput.ContextChain
* [ ] createResultArtefact() calls validateCommitExists() for CodeCommit
* [ ] Git validation failure creates Failure artefact
* [ ] Logs include context size and git validation results

**Testing:**

* [ ] Unit tests for BFS traversal
* [ ] Unit tests for thread tracking
* [ ] Unit tests for filtering
* [ ] Unit tests for sorting
* [ ] Unit tests for git validation
* [ ] Integration test with real Redis
* [ ] Integration test with real git repo
* [ ] E2E test with full workflow

## **9. Operational readiness**

### **9.1. Monitoring and observability**

**Metrics to track:**
* **Context assembly:**
  * Context chain size (artefact count)
  * Context assembly time (ms)
  * Depth reached (max 10)
  * Artefacts filtered out (count)
  * GetLatestVersion() calls (count)

* **Git validation:**
  * Validation attempts (count)
  * Validation successes (count)
  * Validation failures (count)
  * Validation time (ms)

**Log messages:**

**Context assembly:**
* `[INFO] Assembling context for artefact: artefact_id=<uuid>`
* `[DEBUG] BFS level <N>: processing <count> artefacts`
* `[DEBUG] Found latest version: logical_id=<uuid> version=<N>`
* `[DEBUG] Context assembly complete: total=<N> filtered=<N> depth=<N> time=<ms>`
* `[WARN] Depth limit reached: max_depth=10 artefacts_pending=<N>`
* `[ERROR] Failed to fetch artefact: artefact_id=<uuid> error=<error>`

**Git validation:**
* `[INFO] Validating git commit: hash=<hash>`
* `[DEBUG] Git validation passed: hash=<hash> time=<ms>`
* `[ERROR] Git validation failed: hash=<hash> error=<error>`

**Health check modifications:**
* No changes - context assembly doesn't affect health

**Issue detection and diagnosis:**
* **Empty context when expected:** Check artefact graph, verify source_artefacts
* **Wrong context order:** Check created_at timestamps, verify sort logic
* **Git validation failing:** Check workspace is git repo, verify commit exists
* **Context too small:** Check filtering logic, verify artefacts are Standard/Answer

### **9.2. Rollback and disaster recovery**

**Feature disable via configuration:**
* Not applicable - context assembly is core functionality

**Rollback procedure if feature causes issues:**
1. Run `sett down` to stop all containers
2. Revert to M2.3 git commit
3. Rebuild cub binary: `make build-cub`
4. Rebuild agent images
5. Run `sett up` (context_chain will be empty array again)

**Data migration or cleanup requirements:**
* None - M2.4 only reads data, doesn't modify schemas
* Thread tracking already exists from M1.2

**Recovery time objective:**
* **RTO:** <5 minutes (stop, rebuild, restart)
* **RPO:** N/A (no data loss - only reads)

### **9.3. Documentation and training**

**Feature coverage in user guides:**
* Add section: "How Context Assembly Works"
* Document BFS algorithm and thread tracking
* Document context filtering rules
* Document git commit validation
* Provide examples of context_chain structure

**API documentation:**
* **GoDoc comments:** All functions in context.go and git.go
* **Algorithm documentation:** Document BFS steps clearly
* **Contract documentation:** Update ToolInput with context_chain examples

**Troubleshooting guides:**

**Problem:** Context contains wrong artefacts
* **Solution:**
  1. Check artefact graph structure (source_artefacts)
  2. Verify thread tracking has latest versions
  3. Check filtering logic (Standard/Answer only)
  4. Verify chronological ordering

**Problem:** Git validation fails for valid commit
* **Solution:**
  1. Verify workspace is git repository
  2. Check commit hash format (40-char SHA-1)
  3. Verify agent script committed before returning hash
  4. Check workspace path is correct (/workspace)

**Problem:** Context is empty when it shouldn't be
* **Solution:**
  1. Check artefact has source_artefacts
  2. Verify source artefacts exist in Redis
  3. Check filtering didn't remove all artefacts
  4. Verify artefacts have Standard/Answer structural_type

**Team training requirements:**
* Demo context assembly algorithm with visual graph
* Show example context_chain in tool stdin
* Demonstrate git commit workflow in agent script
* Explain thread tracking and versioning

## **10. Recommended commit message format**

While not enforced by the cub, agent scripts should follow this format for consistency and traceability:

```
[sett-agent: {agent-role}] {summary from ToolOutput}

Claim-ID: {claim-id}
```

**Example:**
```
[sett-agent: code-generator] Implemented user authentication endpoint

Claim-ID: claim-abc-123
```

This format:
- Clearly identifies automated commits
- Links commits to specific claims for audit trail
- Maintains consistency across all agents
- Enables filtering/searching of agent commits

## **11. Self-validation checklist**

### **Before starting implementation:**

* [ ] I understand how M2.4 builds on M2.3
* [ ] I understand the BFS algorithm from agent-cub.md
* [ ] I understand thread tracking and GetLatestVersion()
* [ ] I understand context filtering requirements
* [ ] I understand git validation scope (CodeCommit only)
* [ ] All success criteria (section 1.3) are measurable and testable
* [ ] I have considered every component in section 2 explicitly
* [ ] All design decisions (section 3.1) are justified and documented

### **During implementation:**

* [ ] I am implementing the simplest solution that meets success criteria
* [ ] All error scenarios (section 6) are being handled, not just happy path
* [ ] Tests are being written before or alongside code (TDD approach)
* [ ] I am validating that existing functionality is not broken (run M2.3 tests)
* [ ] BFS uses queue correctly (FIFO)
* [ ] GetLatestVersion() called for every logical_id
* [ ] Context map prevents duplicates
* [ ] Filtering removes non-Standard/non-Answer
* [ ] Sorting is chronological (oldest first)
* [ ] Git validation only for CodeCommit

### **Before submission:**

* [ ] All items in Definition of Done (section 5) are complete
* [ ] Feature has been tested in a clean environment from scratch
* [ ] All tests pass with `-race` flag (no race conditions)
* [ ] Documentation is updated and accurate (GoDoc comments, README)
* [ ] I have considered the operational impact (section 9) of this feature
* [ ] E2E test passes with context and git validation
* [ ] Example agent demonstrates context usage
* [ ] Commit message format documented
* [ ] No goroutine leaks detected (process exits cleanly)
