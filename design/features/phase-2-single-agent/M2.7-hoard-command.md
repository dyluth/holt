# **Feature design: M2.7 - Hoard Command (Blackboard Inspection)**

**Purpose**: Implement robust CLI command for inspecting blackboard state
**Scope**: Complete hoard command with list and get modes
**Estimated tokens**: ~4,000 tokens
**Read when**: Implementing hoard functionality, working on CLI inspection features

Associated phase: **Single Agent**
Status: **Approved**

## **1. The 'why': goal and success criteria**

### **1.1. Goal statement**

Provide users with a powerful yet simple command-line interface for inspecting the blackboard state, enabling both high-level overview of all work products and deep-dive inspection of individual artefacts.

### **1.2. User story**

As a Sett user, after running a workflow, I need a way to easily see what artefacts were produced. I want to be able to get a quick overview of everything on the blackboard in a clean table format, and if one item looks interesting, I want to be able to retrieve all of its data for detailed inspection with a single command.

### **1.3. Success criteria**

* A user can run `sett hoard` (with auto-inferred instance) and see a clean, readable table of all artefacts with ID, Type, Produced By, and Payload summary columns
* A user can run `sett hoard <artefact-id>` and receive the complete artefact object as pretty-printed JSON for detailed inspection
* A user can run `sett hoard --output=json` and receive all artefacts as a JSON array suitable for programmatic processing
* When no artefacts exist, the command displays a clear "No artefacts found" message
* When a requested artefact ID doesn't exist, the command displays a clear error and exits with non-zero status
* The command completes in reasonable time even with hundreds of artefacts (uses Redis SCAN)

### **1.4. Non-goals**

* Real-time streaming (--watch flag) - use `sett watch` command instead
* Tree-like dependency visualization - future enhancement
* Complex sorting options (--sort-by flag) - alphabetical by ID is sufficient for now
* Filtering by artefact type or producer - simple listing is sufficient for inspection
* Pagination for large result sets - out of scope for Phase 2

## **2. The 'what': component impact analysis**

### **2.1. Blackboard changes**

**No changes required** - existing read-only operations are sufficient:
* `GetArtefact(ctx, artefactID)` - used in get mode
* Redis SCAN with pattern `sett:{instance}:artefact:*` - used in list mode

### **2.2. Orchestrator changes**

**No changes** - hoard is purely a read-only inspection tool

### **2.3. Agent cub changes**

**No changes** - hoard is purely a read-only inspection tool

### **2.4. CLI changes**

**New command:**

`sett hoard [ARTEFACT_ID]`

**Flags:**
* `--name, -n` (string, optional): Target instance name (auto-inferred from workspace if omitted)
* `--output, -o` (string, default="default"): Output format (default or json) - **ignored when ARTEFACT_ID is provided**

**Behavior modes:**

**Mode A: List Mode (no ARTEFACT_ID argument)**

Displays overview of all artefacts in the instance.

*Default output format:*
```
Artefacts for instance 'sett-test-2024-10-15':

┌──────────────────────────────────────┬─────────────────┬─────────────┬────────────────────────────────────────────────────────────┐
│ ID                                   │ TYPE            │ PRODUCED BY │ PAYLOAD                                                    │
├──────────────────────────────────────┼─────────────────┼─────────────┼────────────────────────────────────────────────────────────┤
│ 25e839bd-2fe9-4c11-84da-e92b603766a8 │ GoalDefined     │ user        │ hello-from-sett.txt                                        │
│ 0f92acfb-414d-447a-b2f0-cd514912ecdd │ CodeCommit      │ git-agent   │ a3f5b8c91d2e4f7a9b1c3d5e6f8a9b0c1d2e3f4a5b6c7d8e9f0a... │
└──────────────────────────────────────┴─────────────────┴─────────────┴────────────────────────────────────────────────────────────┘

2 artefacts found
```

*JSON output format (--output=json):*
```json
[
  {
    "id": "25e839bd-2fe9-4c11-84da-e92b603766a8",
    "logical_id": "cd0c0c7f-4970-4923-aadc-461d2eb05933",
    "version": 1,
    "structural_type": "Standard",
    "type": "GoalDefined",
    "payload": "hello-from-sett.txt",
    "source_artefacts": [],
    "produced_by_role": "user"
  },
  {
    "id": "0f92acfb-414d-447a-b2f0-cd514912ecdd",
    "logical_id": "7aa29e5d-7279-4cd2-b9ed-57a5754266d7",
    "version": 1,
    "structural_type": "Standard",
    "type": "CodeCommit",
    "payload": "a3f5b8c91d2e4f7a9b1c3d5e6f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6",
    "source_artefacts": ["25e839bd-2fe9-4c11-84da-e92b603766a8"],
    "produced_by_role": "git-agent"
  }
]
```

*Empty state:*
```
No artefacts found for instance 'sett-test-2024-10-15'
```

**Mode B: Get Mode (ARTEFACT_ID argument provided)**

Displays complete details of a single artefact.

*Output (always JSON, always pretty-printed):*
```json
{
  "id": "25e839bd-2fe9-4c11-84da-e92b603766a8",
  "logical_id": "cd0c0c7f-4970-4923-aadc-461d2eb05933",
  "version": 1,
  "structural_type": "Standard",
  "type": "GoalDefined",
  "payload": "hello-from-sett.txt",
  "source_artefacts": [],
  "produced_by_role": "user"
}
```

*Not found state (stderr):*
```
✗ Artefact with ID '00000000-0000-0000-0000-000000000000' not found
```
Exit code: 1

### **2.5. New dependency**

**Add table formatting library:**
* Package: `github.com/olekukonko/tablewriter`
* Purpose: Professional table formatting with proper alignment and borders
* Rationale: Battle-tested library, aligns with "Pragmatism over Novelty" principle

## **3. The 'how': implementation & testing plan**

### **3.1. Key design decisions & risks**

**Key Decisions:**

1. **Two-mode behavior based on positional argument**: Clean UX - presence of ARTEFACT_ID determines behavior without needing a flag like `--get`

2. **Ignore --output flag in get mode**: Get mode always outputs JSON (the complete object). The --output flag only affects list mode format (table vs JSON array)

3. **Use tablewriter library**: Professional CLI tools use proven libraries for complex formatting rather than reinventing the wheel

4. **First line only for payload summary**: Multi-line payloads (JSON, commit messages) are truncated to first line in table view, ensuring clean layout

5. **Skip malformed artefacts with warning**: As an inspection/debugging tool, hoard must show as much valid data as possible even if some artefacts are corrupted

6. **Alphabetical sorting by ID**: Provides stable, predictable order across runs (no timestamps on artefacts)

7. **Use Redis SCAN**: Non-blocking iteration over keys, essential for production use with many artefacts

**Risks:**

* **Performance with thousands of artefacts**: SCAN mitigates blocking, but fetching 1000+ artefacts will still take time. Document this as an inspection tool, not real-time monitoring
* **Table rendering with very long type names**: Truncation rules must be consistent. Use tablewriter's auto-wrap feature
* **Payload newlines breaking table layout**: Mitigated by showing first line only
* **Empty blackboard confusion**: Clear "No artefacts found" message addresses this

### **3.2. Implementation steps**

**Phase 1: Command infrastructure (cmd/sett/commands/hoard.go)**
1. Remove "hidden" status from hoard command
2. Update command description and long help text
3. Add `--output` flag validation (default/json)
4. Implement instance inference (reuse existing logic from watch/forage)
5. Connect to blackboard client

**Phase 2: List mode implementation (internal/hoard/list.go)**
1. Create `ListArtefacts()` function
2. Use Redis SCAN with pattern `sett:{instance}:artefact:*`
3. Fetch each artefact, skip malformed with warning to stderr
4. Sort results alphabetically by ID
5. Implement default table formatter:
   - Initialize tablewriter with headers
   - Truncate payload to first line, max 60 chars
   - Use "-" for empty fields
   - Calculate and display total count
6. Implement JSON array formatter
7. Handle empty state (no artefacts)

**Phase 3: Get mode implementation (internal/hoard/get.go)**
1. Create `GetArtefact()` function
2. Fetch single artefact by ID using `bbClient.GetArtefact()`
3. Pretty-print JSON with 2-space indentation
4. Handle not found error with clear message to stderr, exit code 1

**Phase 4: Testing**
1. Unit tests for formatters (table, JSON, truncation logic)
2. Unit tests for error handling (malformed artefacts, not found)
3. Integration tests with miniredis
4. E2E test with real instance

### **3.3. Performance & resource considerations**

**Resource usage:**
* Memory: Proportional to artefact count (each artefact ~200-500 bytes in memory)
* Network: One Redis SCAN + N Redis GET operations (N = artefact count)
* CPU: Minimal - JSON marshaling and table formatting are fast

**Scalability limits:**
* Comfortable with 100-500 artefacts (typical workflow)
* Acceptable with 1000-2000 artefacts (~2-5 seconds)
* Not designed for real-time monitoring of 10,000+ artefacts (use `sett watch` for that)

**Performance optimizations:**
* SCAN cursor-based iteration (non-blocking)
* Parallel artefact fetches possible (future optimization if needed)
* JSON marshaling is built-in and fast

### **3.4. Testing strategy**

**Unit tests:**
* `internal/hoard/format_test.go`: Test table and JSON formatters
  - Test payload truncation (60 char limit)
  - Test first-line extraction from multi-line payloads
  - Test empty field handling ("-" placeholder)
  - Test JSON array output structure
  - Test pretty-print JSON indentation
* `internal/hoard/list_test.go`: Test list logic
  - Test sorting (alphabetical by ID)
  - Test malformed artefact skipping with warning
  - Test empty result set message
* `internal/hoard/get_test.go`: Test get logic
  - Test single artefact retrieval
  - Test not found error handling

**Integration tests:**
* `cmd/sett/commands/hoard_test.go`: Test with miniredis
  - Create test artefacts, verify list mode output
  - Test get mode with valid ID
  - Test get mode with invalid ID (not found)
  - Test empty blackboard state
  - Test --output=json flag

**E2E tests:**
* Add to Phase 2 E2E test suite:
  ```bash
  # After running a workflow with git-agent
  sett forage --goal "test.txt"

  # List all artefacts
  sett hoard
  # Assert: Table with 2+ rows (GoalDefined + CodeCommit)

  # Get specific artefact
  ARTEFACT_ID=$(sett hoard --output=json | jq -r '.[0].id')
  sett hoard $ARTEFACT_ID
  # Assert: Valid JSON object

  # Test not found
  sett hoard 00000000-0000-0000-0000-000000000000
  # Assert: Exit code 1, error message on stderr
  ```

## **4. Principle compliance check**

### **4.1. YAGNI (You Ain't Gonna Need It)**

**New dependencies:**
* `github.com/olekukonko/tablewriter` - Justified: Professional table formatting is non-trivial and this is the standard Go library for CLI tables

**Features omitted (YAGNI applied):**
* Sorting options (--sort-by flag)
* Filtering (--type, --producer flags)
* Pagination
* Tree visualization
* Watch mode for hoard

All omitted features may be valuable in the future, but are not necessary for the core inspection use case.

### **4.2. Auditability**

**Read-only operation**: hoard never writes to the blackboard, only reads. No audit implications.

### **4.3. Small, single-purpose components**

**Component separation:**
* `internal/hoard/list.go` - List mode logic
* `internal/hoard/get.go` - Get mode logic
* `internal/hoard/format.go` - Output formatting (table, JSON)
* `cmd/sett/commands/hoard.go` - CLI command wiring

Each component has a single, clear responsibility.

### **4.4. Security considerations**

**Attack surface analysis:**
* Read-only Redis access (no write operations)
* No user input goes to Redis (artefact ID is validated as UUID)
* No file system writes
* No network operations beyond Redis

**Input validation:**
* Artefact ID must be valid UUID format (validated before Redis query)
* Instance name validation reuses existing logic

### **4.5. Backward compatibility**

**API changes:**
* None - this is a new command feature
* Existing `sett hoard` stub is being promoted to full command (non-breaking)

### **4.6. Dependency impact**

**New dependency: tablewriter**
* License: MIT (permissive)
* Maturity: 5+ years, 4.5k+ stars, widely used
* Size: Small, focused library (~1000 LOC)
* Maintenance: Active, no known security issues

**Go version:**
* No changes - uses existing stdlib features

**Build impact:**
* Negligible compile time increase

## **5. Definition of done**

* [ ] All implementation steps from section 3.2 are complete
* [ ] All tests defined in section 3.4 are implemented and passing
* [ ] List mode displays clean table with correct columns (ID, Type, Produced By, Payload)
* [ ] List mode JSON output produces valid JSON array
* [ ] Get mode displays pretty-printed JSON
* [ ] Empty state displays clear "No artefacts found" message
* [ ] Not found error displays clear message and exits with code 1
* [ ] Malformed artefacts are skipped with warning to stderr
* [ ] Payload truncation works correctly (first line, 60 chars)
* [ ] Sorting is alphabetical by ID
* [ ] Performance is acceptable with 500+ artefacts
* [ ] Overall test coverage has not decreased
* [ ] Documentation is updated (command help text, examples)
* [ ] E2E test validates both modes
* [ ] All error scenarios from section 6 are handled
* [ ] Instance inference works correctly
* [ ] The tablewriter dependency is added to go.mod

## **6. Error scenarios & edge cases**

### **6.1. Failure modes**

**Instance does not exist (for hoard command):**
* Behavior: Fail fast with helpful error
* Error: `✗ Instance 'name' not found. Run 'sett list' to see available instances.`
* Exit code: 1

**No instances found (when auto-inferring):**
* Behavior: Fail with setup guidance
* Error: `✗ No Sett instances found for this workspace. Run 'sett up' to start an instance.`
* Exit code: 1

**Multiple instances found (when auto-inferring):**
* Behavior: Fail with disambiguation guidance
* Error: `✗ Multiple instances found. Use --name to specify: sett hoard --name <instance>`
* Exit code: 1

**Redis unavailable:**
* Behavior: Fail with connection error
* Error: `✗ Cannot connect to Redis at redis://host:port`
* Guidance: "Check that instance is running: sett list"
* Exit code: 1

**Artefact not found (get mode):**
* Behavior: Clear error to stderr, non-zero exit
* Error: `✗ Artefact with ID 'xxx' not found`
* Exit code: 1

**Malformed artefact JSON (list mode):**
* Behavior: Skip artefact, warn to stderr, continue
* Warning: `⚠️  Skipping malformed artefact: key=sett:instance:artefact:xxx (parse error)`
* Exit code: 0 (continues to show valid artefacts)

**Invalid --output format:**
* Behavior: Fail fast with validation error
* Error: `✗ Invalid output format 'xml'. Valid options: default, json`
* Exit code: 1

**Invalid artefact ID format (get mode):**
* Behavior: Fail fast with validation error
* Error: `✗ Invalid artefact ID format. Must be a valid UUID.`
* Exit code: 1

### **6.2. Concurrency considerations**

**Safe concurrency:**
* All operations are read-only - no race conditions with orchestrator or agents
* SCAN is safe during concurrent writes (may see stale snapshot, acceptable for inspection)
* No shared state between hoard invocations

### **6.3. Edge case handling**

**Empty payload:**
* Table: Display "-" in Payload column
* JSON: Include as empty string `"payload": ""`

**Very long artefact type name:**
* Table: Use tablewriter auto-wrap (default behavior)
* JSON: Include full type name

**Payload with newlines (multi-line JSON, commit messages):**
* Table: Show first line only, truncated to 60 chars
* JSON: Include full payload with newlines preserved

**Payload with special characters (tabs, control chars):**
* Table: Show as-is (terminal will render)
* JSON: Properly escaped by json.Marshal

**Zero artefacts in blackboard:**
* Display: `No artefacts found for instance 'instance-name'`
* Exit code: 0 (not an error, just empty state)

**Single artefact in blackboard:**
* Display: Table with 1 row + "1 artefact found"
* Works identically to multiple artefacts case

**Artefact with empty source_artefacts array:**
* Table: Not displayed (only shows ID, Type, Produced By, Payload)
* JSON: Include as empty array `"source_artefacts": []`

**Very large payload (1MB+ git commit hash list):**
* Table: Truncate to first line, 60 chars (acceptable for summary)
* Get mode: Show full payload (user explicitly requested details)
* Performance: json.Marshal handles large strings efficiently

## **7. Open questions & decisions**

All questions resolved during design phase:
* ✅ Table formatting: Use tablewriter library (approved)
* ✅ Payload display: First line only, 60 char truncation (approved)
* ✅ Error handling: Skip malformed with warning (approved)
* ✅ Redis key pattern: Use SCAN with sett:{instance}:artefact:* (approved)
* ✅ Sorting: Alphabetical by ID (approved)
* ✅ Empty fields: Use "-" placeholder (approved)
* ✅ Output flag behavior: Ignored in get mode (approved)

## **8. AI agent implementation guidance**

### **8.1. Development approach**

**Implementation order (critical):**
1. Start with get mode (simpler - single artefact fetch)
2. Add list mode scanning and fetching
3. Implement default table formatter
4. Implement JSON formatters
5. Add error handling throughout
6. Write tests (TDD approach recommended)

**Defensive programming:**
* Validate artefact ID format before Redis query (prevent invalid keys)
* Check for nil artefacts before dereferencing
* Always close blackboard client with defer
* Use stderr for warnings and errors, stdout for data
* Exit with non-zero code on errors (important for scripts)

### **8.2. Common pitfalls to avoid**

**Critical mistakes:**
* ❌ Using Redis KEYS instead of SCAN (blocks server!)
* ❌ Not handling multi-line payloads (breaks table layout)
* ❌ Writing warnings/errors to stdout (pollutes data output)
* ❌ Exit code 0 on "not found" errors (breaks shell scripts)
* ❌ Not truncating payloads (table becomes unreadable)
* ❌ Sorting by insertion order (unstable, unpredictable)

**Testing pitfalls:**
* ❌ Not testing empty blackboard state
* ❌ Not testing malformed JSON in Redis
* ❌ Not testing payload truncation edge cases (exactly 60 chars, etc.)

### **8.3. Integration checklist**

Pre-implementation verification:
* [ ] Understand tablewriter API (headers, append rows, render)
* [ ] Understand Redis SCAN cursor behavior
* [ ] Review existing instance inference logic (watch.go, forage.go)
* [ ] Review blackboard.GetArtefact() error handling

## **9. Operational readiness**

### **9.1. Monitoring and observability**

**Metrics to track:**
* None - hoard is a CLI command, not a service
* Users can observe execution time directly

**Structured logging events:**
* Not applicable - CLI tool with direct user output

### **9.2. Rollback and disaster recovery**

**Feature disable:**
* N/A - pure read-only CLI command
* Users simply don't run the command if there are issues

**Rollback procedure:**
* Revert to previous CLI binary version if bugs discovered
* No data migration needed (read-only)

### **9.3. Documentation and training**

**CLI command documentation:**
* Update `sett hoard --help` with full description
* Add examples for both modes
* Document --output flag behavior

**Example documentation to add:**
```bash
# List all artefacts in current workspace instance
sett hoard

# List all artefacts for specific instance
sett hoard --name prod-instance

# Get artefacts as JSON array for scripting
sett hoard --output=json | jq '.[] | select(.type=="CodeCommit")'

# Get full details of specific artefact
sett hoard abc123-def456-...

# Pipe artefact IDs to other commands
sett hoard --output=json | jq -r '.[].id' | head -1
```

**Troubleshooting guide additions:**
* "hoard shows no artefacts" → Verify instance is running, check Redis connection
* "Malformed artefact warnings" → Redis data corruption, may need manual cleanup
* "Table formatting looks wrong" → Terminal width issue, try JSON output

## **10. Self-validation checklist**

### **Before starting implementation:**

* [x] I understand how this feature fits in Phase 2 (inspection/debugging tool)
* [x] All success criteria (section 1.3) are measurable and testable
* [x] I have considered every component in section 2 explicitly
* [x] All design decisions (section 3.1) are justified and documented
* [x] Non-goals are clearly stated (section 1.4)

### **During implementation:**

* [ ] I am implementing the simplest solution that meets success criteria
* [ ] All error scenarios (section 6) are being handled, not just happy path
* [ ] Tests are being written before or alongside code (TDD approach)
* [ ] I am validating that existing functionality is not broken
* [ ] Performance testing with 500+ artefacts shows acceptable speed

### **Before submission:**

* [ ] All items in Definition of Done (section 5) are complete
* [ ] Feature has been tested in a clean environment from scratch
* [ ] Both list mode and get mode work correctly
* [ ] Empty state and not-found state are handled properly
* [ ] Documentation is updated and accurate (--help text, examples)
* [ ] Malformed artefact handling is robust (skip with warning)
* [ ] Table output is clean and readable
* [ ] JSON output is valid and pretty-printed
