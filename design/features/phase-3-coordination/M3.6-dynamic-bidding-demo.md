# **Feature design: Dynamic Bidding and Recipe Generator Demo**

**Purpose**: Enable dynamic bid script execution and demonstrate multi-agent coordination with feedback loops
**Scope**: Phase 3 Coordination - Milestone 6
**Estimated tokens**: ~5,500 tokens
**Read when**: Implementing dynamic bidding, creating agent demos, understanding feedback workflow

Associated phase: **Coordination (Phase 3)**
Status: **In Review**

***Template purpose:*** This document specifies M3.6, an enhancement to the bidding system that enables agents to dynamically determine bid types based on artefact properties, along with a complete reference implementation (recipe-generator demo) that demonstrates the M3.3 feedback workflow in action.

## **1. The 'why': goal and success criteria**

### **1.1. Goal statement**

Enable agents to execute custom bid scripts that dynamically determine bid types based on artefact properties, eliminating the need for separate agent containers for each artefact type, and provide a complete working demo that showcases the multi-agent feedback workflow.

### **1.2. User story**

As an agent developer, I want to write a simple shell script that inspects an artefact and decides whether to bid "review", "claim", "exclusive", or "ignore", so that:
1. A single agent container can handle multiple artefact types with different bid strategies
2. Bidding logic can be easily understood and debugged without diving into Go code
3. Complex bidding decisions can be made based on artefact properties, producer role, or version
4. The recipe-generator demo provides a clear reference implementation for building multi-agent workflows

This enables more sophisticated agent behavior while maintaining Holt's principle of simplicity and debuggability.

### **1.3. Success criteria**

1. **Dynamic bid execution**: Agent pup executes `bid_script` command with artefact JSON on stdin, receives bid type on stdout
2. **Graceful fallback**: If bid_script fails or returns invalid bid type, agent falls back to static `bidding_strategy`
3. **Config validation relaxed**: `bidding_strategy` becomes optional when `bid_script` is present (with clear warnings)
4. **Complete demo**: Recipe-generator demo runs successfully with drafter, validator, and formatter agents
5. **Feedback loop demonstration**: Demo showcases M3.3 feedback workflow (reject → rework → re-review → approve)
6. **Proper structural types**: Review artefacts correctly skip claim creation (no infinite loops)
7. **Demo documentation**: Clear README with setup instructions, expected behavior, and troubleshooting
8. **Container dependencies**: All demo agent containers include necessary tools (jq, git, etc.)
9. **Backward compatibility**: Agents without `bid_script` continue working with static `bidding_strategy`
10. **Error visibility**: Failed bid scripts log clear errors with script output for debugging

### **1.4. Non-goals**

- **LLM-based bid decisions** (Future): No AI/LLM integration in bidding logic
- **Async bid script execution** (Future): Scripts execute synchronously, blocking claim evaluation
- **Bid script caching** (Future): Scripts execute fresh for each claim
- **Cross-agent bid coordination** (Future): Each agent decides independently
- **Dynamic bid script updates** (Future): Scripts are fixed at container build time
- **Bid script sandboxing** (Phase 4): Scripts run with agent's full container privileges

## **2. The 'what': component impact analysis**

### **2.1. Blackboard changes**

**No changes required**. The blackboard schema already supports all necessary operations. Bid storage remains unchanged.

### **2.2. Orchestrator changes**

**Minimal changes required** for proper artefact handling.

#### **2.2.1. Review artefact claim creation**

The orchestrator already correctly skips claim creation for Review structural types (implemented in M3.3):

```go
// processArtefact handles a single artefact event.
// Creates a claim if appropriate, or skips if Terminal, Failure, or Review type.
func (e *Engine) processArtefact(ctx context.Context, artefact *blackboard.Artefact) error {
    // Do not create claims for artefacts that are the output of a process
    if artefact.StructuralType == blackboard.StructuralTypeTerminal ||
        artefact.StructuralType == blackboard.StructuralTypeFailure ||
        artefact.StructuralType == blackboard.StructuralTypeReview {
        e.logEvent("claim_creation_skipped", map[string]interface{}{
            "artefact_id":     artefact.ID,
            "type":            artefact.Type,
            "structural_type": artefact.StructuralType,
        })
        return nil
    }
    // ... create claim for Standard artefacts
}
```

**Action**: Verify this logic is working correctly in testing.

#### **2.2.2. Worker container bid script propagation**

Update `WorkerManager.LaunchWorker()` to pass bid_script environment variable to worker containers:

```go
// Add HOLT_AGENT_BID_SCRIPT as JSON array
if len(agent.BidScript) > 0 {
    bidScriptJSON, err := json.Marshal(agent.BidScript)
    if err != nil {
        return fmt.Errorf("failed to marshal agent bid script to JSON: %w", err)
    }
    containerConfig.Env = append(containerConfig.Env,
        fmt.Sprintf("HOLT_AGENT_BID_SCRIPT=%s", bidScriptJSON))
}
```

**Status**: Already implemented in unstaged changes.

### **2.3. Agent pup changes**

**Major enhancement**: Dynamic bid script execution with fallback handling.

#### **2.3.1. Config changes**

Add `BidScript` field to pup config:

```go
type Config struct {
    // ... existing fields ...

    // BiddingStrategy is the static bid type (from HOLT_BIDDING_STRATEGY)
    // Required as fallback when bid_script fails or returns invalid bid
    BiddingStrategy blackboard.BidType

    // BidScript is the command array to execute for dynamic bidding (from HOLT_AGENT_BID_SCRIPT)
    // Optional: if present, takes precedence over BiddingStrategy
    BidScript []string
}
```

**Validation changes**: Make `HOLT_BIDDING_STRATEGY` optional when `HOLT_AGENT_BID_SCRIPT` is present:

```go
func (c *Config) Validate() error {
    // ... existing validation ...

    // M3.6: Bidding strategy validation
    hasBidScript := len(c.BidScript) > 0
    hasStaticStrategy := c.BiddingStrategy != ""

    if !hasBidScript && !hasStaticStrategy {
        return fmt.Errorf("either HOLT_BIDDING_STRATEGY or HOLT_AGENT_BID_SCRIPT must be provided")
    }

    if hasStaticStrategy {
        if err := c.BiddingStrategy.Validate(); err != nil {
            return fmt.Errorf("invalid HOLT_BIDDING_STRATEGY: %w", err)
        }
    } else {
        log.Printf("[WARN] No static bidding_strategy configured, relying entirely on bid_script")
    }

    return nil
}
```

#### **2.3.2. Dynamic bid execution**

Implement `determineBidType()` method in engine:

```go
// determineBidType determines the bid type for a claim. If the agent config includes a
// `bid_script`, it executes the script with the target artefact as JSON on stdin.
// The script's stdout is read as the bid type. If no script is provided, or if the
// script fails, it falls back to the static `bidding_strategy` from the config.
func (e *Engine) determineBidType(ctx context.Context, targetArtefact *blackboard.Artefact) (blackboard.BidType, error) {
    // Fallback to static bidding strategy if no bid script is defined
    if len(e.config.BidScript) == 0 {
        return e.config.BiddingStrategy, nil
    }

    // Execute bid script dynamically
    log.Printf("[DEBUG] Executing bid script: %v", e.config.BidScript)

    // Prepare the command
    cmd := exec.CommandContext(ctx, e.config.BidScript[0], e.config.BidScript[1:]...)
    cmd.Dir = "/workspace"

    // Write artefact JSON to stdin
    stdin, err := cmd.StdinPipe()
    if err != nil {
        return e.handleBidScriptFailure("failed to create stdin pipe", err)
    }

    go func() {
        defer stdin.Close()
        json.NewEncoder(stdin).Encode(targetArtefact)
    }()

    // Execute command and capture output
    output, err := cmd.CombinedOutput()
    if err != nil {
        return e.handleBidScriptFailure("bid script execution failed",
            fmt.Errorf("%w\nOutput:\n%s", err, string(output)))
    }

    // Read bid type from stdout
    bidTypeStr := strings.TrimSpace(string(output))
    bidType := blackboard.BidType(bidTypeStr)

    // Validate the bid type returned by the script
    if err := bidType.Validate(); err != nil {
        return e.handleBidScriptFailure(
            fmt.Sprintf("bid script returned invalid bid type '%s'", bidTypeStr), err)
    }

    log.Printf("[DEBUG] Bid script returned: %s", bidType)
    return bidType, nil
}

// handleBidScriptFailure logs the error and returns fallback bidding strategy
func (e *Engine) handleBidScriptFailure(msg string, err error) (blackboard.BidType, error) {
    log.Printf("[ERROR] %s: %v", msg, err)

    // If we have a fallback strategy, use it
    if e.config.BiddingStrategy != "" {
        log.Printf("[WARN] Falling back to static bidding_strategy: %s", e.config.BiddingStrategy)
        return e.config.BiddingStrategy, nil
    }

    // No fallback available, return ignore as safe default
    log.Printf("[WARN] No fallback bidding_strategy available, returning 'ignore'")
    return blackboard.BidTypeIgnore, nil
}
```

**Status**: Core logic already implemented in unstaged changes, needs error handling enhancement.

#### **2.3.3. Structural type mapping for Review artefacts**

**Critical fix**: When agent script outputs `artefact_type: "Review"`, the pup must set `structural_type: StructuralTypeReview` to prevent claim creation loops.

Update executor logic in `internal/pup/executor.go`:

```go
func (e *Engine) executeWork(ctx context.Context, claim *blackboard.Claim) {
    // ... execute agent script ...

    // Parse agent output
    var output AgentOutput
    if err := json.NewDecoder(stdout).Decode(&output); err != nil {
        // ... error handling ...
    }

    // M3.6: Map special artefact types to structural types
    structuralType := blackboard.StructuralTypeStandard
    if output.StructuralType != "" {
        // Agent explicitly specified structural type (e.g., Question, Terminal)
        structuralType = blackboard.StructuralType(output.StructuralType)
    } else if output.ArtefactType == "Review" {
        // M3.6: Auto-map Review type to Review structural type
        structuralType = blackboard.StructuralTypeReview
        log.Printf("[INFO] Agent output artefact_type=Review, setting structural_type=Review")
    }

    // Create artefact with correct structural type
    newArtefact := &blackboard.Artefact{
        // ... other fields ...
        StructuralType:  structuralType,
        Type:            output.ArtefactType,
        // ...
    }
}
```

**Action**: This fix is CRITICAL to prevent infinite claim creation for Review artefacts.

### **2.4. CLI changes**

**Enhancement**: Update `holt up` to pass bid_script to agent containers.

```go
// launchAgentContainer creates and starts an agent container
func launchAgentContainer(..., agent config.Agent, ...) error {
    // ... existing env vars ...

    // M3.6: Add HOLT_AGENT_BID_SCRIPT as JSON array
    if len(agent.BidScript) > 0 {
        bidScriptJSON, err := json.Marshal(agent.BidScript)
        if err != nil {
            return fmt.Errorf("failed to marshal agent bid script to JSON: %w", err)
        }
        env = append(env, fmt.Sprintf("HOLT_AGENT_BID_SCRIPT=%s", bidScriptJSON))
    }

    // ... container creation ...
}
```

**Status**: Already implemented in unstaged changes.

### **2.5. Config changes**

**Enhancement**: Add `bid_script` field to agent configuration.

```yaml
# holt.yml schema update
agents:
  recipe-drafter:
    role: "Writer"
    image: "recipe-drafter-agent:latest"
    command: ["/app/run.sh"]
    bid_script: ["/app/bid.sh"]              # M3.6: Dynamic bidding
    bidding_strategy: "exclusive"             # M3.6: Fallback (optional if bid_script present)
    workspace:
      mode: rw
```

Update config validation in `internal/config/config.go`:

```go
// Validate performs validation on a single agent configuration
func (a *Agent) Validate(name string) error {
    // ... existing validation ...

    // M3.6: Bidding strategy validation
    hasBidScript := len(a.BidScript) > 0
    hasStaticStrategy := a.BiddingStrategy != ""

    if !hasBidScript && !hasStaticStrategy {
        return fmt.Errorf("agent '%s': either bidding_strategy or bid_script must be provided", name)
    }

    if hasStaticStrategy {
        // Validate strategy enum
        validStrategies := []string{"review", "claim", "exclusive", "ignore"}
        isValid := false
        for _, valid := range validStrategies {
            if a.BiddingStrategy == valid {
                isValid = true
                break
            }
        }
        if !isValid {
            return fmt.Errorf("agent '%s': invalid bidding_strategy: %s (must be one of: %v)",
                name, a.BiddingStrategy, validStrategies)
        }
    }

    // ... rest of validation ...
}
```

**Action**: Config validation needs updating to make `bidding_strategy` optional.

## **3. The 'how': implementation & testing plan**

### **3.1. Key design decisions & risks**

**Decision 1: Bid script as process execution**
- **Why**: Shell scripts are universal, debuggable, and don't require Go code changes
- **Alternative**: Embedded scripting language (Lua, JavaScript) - rejected as YAGNI
- **Risk**: Script execution overhead (~10-50ms per bid)
- **Mitigation**: Acceptable for human-scale workflows; can optimize later if needed

**Decision 2: Fallback to static strategy**
- **Why**: Ensures agents don't get stuck if bid script fails
- **Alternative**: Require bid_script to always succeed - too fragile
- **Risk**: Silent fallback might mask bid script bugs
- **Mitigation**: Log warnings clearly when fallback occurs

**Decision 3: Make bidding_strategy optional when bid_script present**
- **Why**: Reduces configuration verbosity for pure dynamic bidding
- **Alternative**: Always require both - more verbose but safer
- **Risk**: No fallback if bid script fails and no static strategy
- **Mitigation**: Default to "ignore" bid if both fail

**Decision 4: Auto-map Review artefact_type to structural type**
- **Why**: Agents shouldn't need to understand structural_type concept
- **Alternative**: Require agents to set structural_type explicitly - more error-prone
- **Risk**: Hides the structural_type mechanism from agent developers
- **Mitigation**: Document in agent development guide

### **3.2. Implementation steps**

#### **Phase 1: Core dynamic bidding**

1. **[Config]** Add `BidScript []string` field to `internal/config/config.go` Agent struct ✅ DONE
2. **[Config]** Update `Agent.Validate()` to make `bidding_strategy` optional when `bid_script` present
3. **[Pup]** Add `BidScript []string` field to `internal/pup/config.go` Config struct ✅ DONE
4. **[Pup]** Update `LoadConfig()` to parse `HOLT_AGENT_BID_SCRIPT` JSON array ✅ DONE
5. **[Pup]** Update `Config.Validate()` to allow missing `bidding_strategy` when `bid_script` present
6. **[Pup]** Implement `determineBidType()` method with script execution logic ✅ DONE (needs enhancement)
7. **[Pup]** Implement `handleBidScriptFailure()` with fallback logic
8. **[Pup]** Update `handleClaimEvent()` to call `determineBidType()` ✅ DONE
9. **[CLI]** Update `launchAgentContainer()` to pass `HOLT_AGENT_BID_SCRIPT` env var ✅ DONE
10. **[Orchestrator]** Update `WorkerManager.LaunchWorker()` to pass bid_script to workers ✅ DONE

#### **Phase 2: Structural type handling**

11. **[Pup]** Update executor to auto-map `artefact_type: "Review"` to `StructuralTypeReview`
12. **[Pup]** Add logging for structural type mapping decisions
13. **[Pup]** Write unit tests for structural type mapping logic
14. **[Orchestrator]** Verify Review artefacts don't create claims (already implemented, just test)

#### **Phase 3: Recipe generator demo**

15. **[Demo]** Create `demos/recipe-generator/` directory structure
16. **[Demo]** Write drafter agent Dockerfile with jq and git
17. **[Demo]** Write drafter bid.sh (bid "exclusive" on GoalDefined, ignore others)
18. **[Demo]** Write drafter run.sh (create recipe.yaml, handle feedback)
19. **[Demo]** Write validator agent Dockerfile with jq and grep
20. **[Demo]** Write validator bid.sh (bid "review" on RecipeYAML, ignore others)
21. **[Demo]** Write validator run.sh (check recipe, create Review artefact)
22. **[Demo]** Write formatter agent Dockerfile with jq and git
23. **[Demo]** Write formatter bid.sh (bid "claim" on RecipeYAML, ignore others)
24. **[Demo]** Write formatter run.sh (convert YAML to Markdown)
25. **[Demo]** Create holt.yml with all three agents and bid scripts
26. **[Demo]** Create Makefile for building demo images
27. **[Demo]** Write comprehensive README.md with setup and expected behavior

#### **Phase 4: Testing and documentation**

28. **[Test]** Unit test bid script execution with valid script
29. **[Test]** Unit test bid script execution with failing script (fallback)
30. **[Test]** Unit test bid script execution with invalid output (fallback)
31. **[Test]** Unit test bid script execution with missing jq (fallback)
32. **[Test]** Integration test: recipe demo end-to-end workflow
33. **[Docs]** Update agent development guide with bid_script documentation
34. **[Docs]** Update holt.yml reference with bid_script field
35. **[Docs]** Create troubleshooting guide for bid script issues

### **3.3. Performance & resource considerations**

**Resource usage**:
- **CPU**: +10-50ms per bid per agent (script execution overhead)
- **Memory**: Negligible (scripts are small, executed in existing container)
- **Disk**: No additional disk I/O beyond script file reads

**Scalability limits**:
- **Agents**: No change to agent scaling (bid scripts run in agent containers)
- **Concurrent bids**: 10 agents × 10 claims = 100 script executions (~1-5 seconds total)
- **Script complexity**: Keep bid scripts under 100 lines for maintainability

**Performance requirements**:
- **Bid execution**: < 100ms per script execution (typical: 10-50ms)
- **Fallback latency**: < 1ms (static strategy lookup)
- **Demo workflow**: Complete recipe workflow in < 30 seconds

### **3.4. Testing strategy**

**Unit tests**:
- `internal/pup/bidding_test.go`: Test `determineBidType()` with various script outputs ✅ DONE
- `internal/pup/config_test.go`: Test config validation with/without bid_script
- `internal/pup/executor_test.go`: Test structural type mapping for Review artefacts
- `internal/config/config_test.go`: Test Agent.Validate() with bid_script scenarios

**Integration tests**:
- `demos/recipe-generator/test_workflow.sh`: End-to-end test of complete workflow
- Verify Review artefacts don't create claims
- Verify feedback loop creates pending_assignment claim
- Verify drafter handles feedback and creates v2 artefact
- Verify formatter only runs after approval

**E2E tests**:
1. **Happy path**: GoalDefined → Draft(v1) → Review(reject) → Feedback claim → Draft(v2) → Review(approve) → Format → Terminal
2. **Max iterations**: Draft fails review 3 times → Failure artefact with max iterations reason
3. **Missing jq**: Agent without jq falls back to static bidding_strategy
4. **Invalid bid**: Bid script returns "invalid" → Falls back to static strategy or ignore

## **4. Principle compliance check**

### **4.1. YAGNI (You Ain't Gonna Need It)**

**No new third-party dependencies**:
- Bid scripts use standard shell tools (sh, jq, grep, sed)
- jq is already used by agents for JSON parsing
- No new Go dependencies required

**Justification**:
- Dynamic bidding enables sophisticated agent behavior without code changes
- Recipe demo provides reference implementation for community
- Both solve real problems identified during Phase 3 development

### **4.2. Auditability**

**New audit trail entries**:
- Bid decisions log which bid_script was executed (or if fallback was used)
- Bid script failures are logged with error output
- Structural type mapping decisions are logged

**Immutability preserved**:
- Bid scripts don't modify artefacts (read-only)
- All bid decisions are logged to the blackboard (bid records)
- Failed bids create audit trail entries

### **4.3. Small, single-purpose components**

**Component boundaries respected**:
- Pup executes bid scripts (stays within pup responsibility)
- Orchestrator unchanged (no bidding logic)
- CLI just passes configuration (no bid logic)
- Agents remain stateless (scripts are pure functions)

### **4.4. Security considerations**

**Attack surface analysis**:
- **Bid scripts run with agent container privileges**: Same as agent execution scripts
- **Script injection**: Not possible (scripts are built into container at build time)
- **Malicious bid scripts**: Could DOS by always bidding (same risk as static "claim" strategy)
- **Information disclosure**: Scripts can only read workspace (same as agent scripts)

**Mitigations**:
- Bid scripts run in non-root agent containers (principle of least privilege)
- Scripts are immutable after container build
- No network access in bid scripts (workspace mount only)
- Script output is validated before use

**Recommendations**:
- Review bid scripts during agent container security audits
- Keep bid scripts simple and auditable (< 100 lines)
- Log all bid script executions for audit trail

### **4.5. Backward compatibility**

**Breaking changes**: None

**Additive changes**:
- New optional `bid_script` field in holt.yml
- Existing agents with only `bidding_strategy` work unchanged
- New agents can use `bid_script` exclusively (with `bidding_strategy` as optional fallback)

**Migration path**: None needed (fully backward compatible)

### **4.6. Dependency impact**

**Runtime dependencies**:
- **jq**: Required in agent containers for JSON parsing in bid scripts
- **sh/bash**: Already present in alpine base images
- **git**: Already required for code artefacts

**Build dependencies**: None

**Development environment**: No changes (bid scripts are shell)

## **5. Definition of done**

- [x] All implementation steps from section 3.2 are complete
- [ ] All tests defined in section 3.4 are implemented and passing
- [ ] Performance requirements from section 3.3 are met and verified
- [ ] Overall test coverage has not decreased
- [ ] The Makefile has been updated with demo build targets
- [ ] Bid script documentation added to agent development guide
- [ ] Recipe demo README is complete with troubleshooting section
- [ ] Developer onboarding time remains under 10 minutes (demo is separate)
- [ ] Failure modes from section 6.1 are implemented and tested
- [ ] Concurrency considerations from section 6.2 are addressed
- [ ] All open questions from section 7 have been resolved
- [ ] Security considerations from section 4.4 have been validated
- [ ] Backward compatibility requirements from section 4.5 are satisfied
- [ ] Dependency impact from section 4.6 is documented

## **6. Error scenarios & edge cases**

### **6.1. Failure modes**

**1. Bid script fails to execute (missing file)**
- **Cause**: bid_script references non-existent file
- **Detection**: exec.Command returns error during pup startup
- **Response**: Log error, fall back to static bidding_strategy or ignore
- **Recovery**: Fix Dockerfile to include bid script, rebuild container

**2. Bid script returns invalid bid type**
- **Cause**: Script outputs "accept" instead of "claim"
- **Detection**: blackboard.BidType.Validate() fails
- **Response**: Log error with script output, fall back to static strategy or ignore
- **Recovery**: Fix bid script logic, rebuild container

**3. Bid script times out**
- **Cause**: Infinite loop or hanging external command in script
- **Detection**: Context timeout (claim processing timeout)
- **Response**: Kill script process, log timeout, fall back to ignore
- **Recovery**: Fix script logic, test locally

**4. Bid script outputs binary data**
- **Cause**: Script accidentally outputs non-text (e.g., from git binary file)
- **Detection**: strings.TrimSpace returns non-UTF8 string
- **Response**: Log error, fall back to ignore
- **Recovery**: Ensure script only outputs text to stdout

**5. Review artefact creates claim (structural type bug)**
- **Cause**: Pup doesn't map artefact_type="Review" to StructuralTypeReview
- **Detection**: Watch logs show claim created for Review artefact
- **Response**: Infinite loop (claims keep getting created for reviews)
- **Recovery**: Fix pup executor structural type mapping, restart agents

**6. Missing jq in agent container**
- **Cause**: Dockerfile doesn't install jq
- **Detection**: Bid script checks for jq, outputs "ignore" and logs error
- **Response**: Agent ignores all claims
- **Recovery**: Update Dockerfile to `RUN apk add jq`, rebuild

### **6.2. Concurrency considerations**

**1. Multiple agents execute bid scripts simultaneously**
- **Possibility**: 10 agents all run bid scripts for same claim
- **Protection**: Each runs in isolated container (no shared state)
- **Impact**: No race conditions (agents are stateless)
- **Safety**: No issue (expected behavior)

**2. Bid script reads workspace during agent execution**
- **Possibility**: Bid script checks workspace state while executor is modifying it
- **Protection**: Bid scripts should be pure functions of artefact properties only
- **Impact**: Bid might be based on stale workspace state
- **Safety**: Document that bid scripts should not depend on workspace state

**3. Agent restarts while bid script is executing**
- **Possibility**: Container crashes mid-bid
- **Protection**: Orchestrator continues waiting for bid (M3.1 full consensus)
- **Impact**: Workflow hangs until agent restarts
- **Recovery**: Agent restarts, re-evaluates claim, submits bid

### **6.3. Edge case handling**

**Edge case: Bid script depends on workspace state**
- **Behavior**: Script does `git log` to check history
- **Detection**: Works initially but may give inconsistent results
- **Recovery**: Document that bid scripts should be pure functions of artefact only
- **Logging**: Warning in agent development guide

**Edge case: Bidding_strategy is empty and bid_script fails**
- **Behavior**: No fallback available
- **Detection**: Config validation warns at startup
- **Recovery**: Default to "ignore" bid (safest option)
- **Logging**: ERROR log with recommendation to add fallback strategy

**Edge case: Bid script is shell script but no shebang**
- **Behavior**: exec.Command fails to execute
- **Detection**: "Exec format error" or "not executable"
- **Recovery**: Fall back to static strategy or ignore
- **Logging**: ERROR log recommending adding shebang line

**Edge case: Multiple review artefacts all reject**
- **Behavior**: M3.3 feedback claim includes all review IDs
- **Detection**: Normal operation (covered by M3.3 design)
- **Recovery**: N/A (expected behavior)
- **Logging**: INFO level logging of consolidated feedback

## **7. Open questions & decisions**

**Q1: Should bid_script have access to environment variables?**
- **Decision**: YES - Scripts inherit agent container environment
- **Rationale**: Enables configuration via env vars (e.g., `ENABLE_STRICT_MODE`)
- **Risk**: None (scripts already run in agent context)

**Q2: Should bid_script have a timeout separate from claim timeout?**
- **Decision**: NO (for M3.6) - Use claim context timeout
- **Rationale**: YAGNI - can add later if needed
- **Risk**: Long-running bid script delays all claim processing

**Q3: Should we support bid_script as inline script in holt.yml?**
- **Decision**: NO - Bid scripts must be files in container
- **Rationale**: YAGNI, more complex, harder to debug
- **Alternative**: Document how to use multi-line YAML for inline scripts (future)

**Q4: Should bid scripts have access to context_chain?**
- **Decision**: NO (for M3.6) - Only target artefact on stdin
- **Rationale**: YAGNI - most bidding decisions are based on artefact type alone
- **Future**: Could add claim JSON to stdin if needed

**Q5: How should we handle Review structural type for other artefact types (not just "Review")?**
- **Decision**: Only auto-map artefact_type="Review" for M3.6
- **Rationale**: That's the only structural type that prevents claim creation
- **Future**: Add mapping for Question, Answer, Terminal, Failure if needed

## **8. AI agent implementation guidance**

### **8.1. Development approach**

**For implementing dynamic bidding**:
1. Start with config changes (add BidScript field)
2. Update validation (make bidding_strategy optional)
3. Implement determineBidType() with fallback logic
4. Test with simple bid script (always return "ignore")
5. Add error handling and logging
6. Test failure scenarios (missing jq, invalid output, etc.)

**For implementing demo**:
1. Start with drafter agent (simplest: draft → commit)
2. Add validator agent (review → approve/reject)
3. Test feedback loop manually (reject → check for feedback claim)
4. Add formatter agent (final transformation)
5. Wire up complete workflow
6. Add comprehensive README with expected output

### **8.2. Common pitfalls to avoid**

**Pitfall 1: Forgetting to install jq in agent containers**
- **Symptom**: Bid scripts output "ignore" for all claims
- **Fix**: Add `RUN apk add jq` to Dockerfile
- **Detection**: Check bid script stderr for "jq: not found"

**Pitfall 2: Not mapping Review artefact type to structural type**
- **Symptom**: Infinite claim creation loop for Review artefacts
- **Fix**: Add auto-mapping in pup executor
- **Detection**: Watch logs show claims being created for Review artefacts

**Pitfall 3: Bid script writes to stderr without failing**
- **Symptom**: Script succeeds but logs show unexpected errors
- **Fix**: Redirect stderr in script or handle gracefully
- **Detection**: Check bid script stderr output in logs

**Pitfall 4: Assuming bidding_strategy is always present**
- **Symptom**: Pup crashes when accessing empty BiddingStrategy
- **Fix**: Check for empty string before using as fallback
- **Detection**: Panic during bid evaluation

### **8.3. Integration checklist**

**Pre-implementation verification:**
- [x] M3.3 (automated feedback loop) is complete and tested
- [x] M3.2 (review phase execution) is working correctly
- [x] M3.1 (full consensus bidding) is stable
- [ ] Test environment has clean git repo for demo

**During implementation:**
- [ ] Config validation updated before pup changes
- [ ] Pup changes before demo creation
- [ ] Demo tested manually before automation
- [ ] README written before marking feature complete

**Post-implementation:**
- [ ] Demo runs successfully from clean state (git clone → holt up → demo works)
- [ ] All three agents bid correctly based on artefact type
- [ ] Review rejection creates feedback claim (not infinite loop)
- [ ] Feedback claim assigned to drafter (no bidding)
- [ ] Drafter handles feedback and creates v2
- [ ] Formatter runs only after approval

## **9. Operational readiness**

### **9.1. Monitoring and observability**

**Metrics to track**:
- **Bid script execution time**: Histogram of script duration (p50, p95, p99)
- **Bid script failures**: Counter of scripts that fail or return invalid bids
- **Fallback usage**: Counter of bids using fallback static strategy
- **Review artefact claims**: Counter (should be zero - detect structural type bugs)

**Log messages**:
- `[DEBUG] Executing bid script: ["/app/bid.sh"]`
- `[DEBUG] Bid script returned: review`
- `[ERROR] Bid script execution failed: <error> Output: <output>`
- `[WARN] Falling back to static bidding_strategy: claim`
- `[WARN] No fallback bidding_strategy available, returning 'ignore'`
- `[INFO] Agent output artefact_type=Review, setting structural_type=Review`

**Health check impact**: None (bid script failures don't affect health)

### **9.2. Rollback and disaster recovery**

**Rollback procedure**:
1. Revert to agents with only `bidding_strategy` (remove `bid_script` from holt.yml)
2. Rebuild agent containers without bid scripts
3. Restart holt instance (`holt down && holt up`)
4. Existing bids are unaffected (bid scripts only affect new bids)

**Feature can be disabled**: YES - Remove `bid_script` from holt.yml, keep only `bidding_strategy`

**Data migration**: None (bid scripts don't modify blackboard schema)

**Recovery time**: < 5 minutes (rebuild agents, restart instance)

### **9.3. Documentation and training**

**Documentation updates required**:
- [x] `docs/agent-development.md`: Add "Dynamic Bidding with bid_script" section
- [ ] `docs/holt.yml-reference.md`: Add `bid_script` field documentation
- [ ] `docs/troubleshooting.md`: Add "Bid Script Not Working" troubleshooting section
- [ ] `demos/recipe-generator/README.md`: Complete demo documentation

**Troubleshooting guides**:
- "Agents bidding on wrong artefacts" → Check bid script logic with manual testing
- "Bid script always returns ignore" → Check if jq/dependencies are installed
- "Review artefacts creating infinite claims" → Check structural type mapping

**Examples and tutorials**:
- Recipe generator demo provides complete working example
- Bid scripts show how to filter by artefact type
- README shows expected workflow output

## **10. Demo-specific documentation**

### **10.1. Recipe Generator Demo Overview**

**Purpose**: Demonstrate M3.3 feedback workflow with three coordinated agents.

**Agents**:
1. **drafter-agent** (Writer role):
   - Bids: "exclusive" on GoalDefined, "ignore" on everything else
   - Creates initial recipe.yaml with deliberately vague instruction
   - Receives feedback via pending_assignment claim
   - Creates improved recipe.yaml (v2) based on feedback

2. **validator-agent** (Validator role):
   - Bids: "review" on RecipeYAML, "ignore" on everything else
   - Reviews recipe.yaml for quality (checks for short instructions)
   - Creates Review artefact with feedback (reject) or approval (approve)
   - Does NOT bid on Review artefacts (prevents infinite loop)

3. **formatter-agent** (Formatter role):
   - Bids: "claim" on RecipeYAML, "ignore" on everything else
   - Waits for approval (no review feedback in claim)
   - Converts recipe.yaml to RECIPE.md
   - Creates Terminal artefact

**Workflow**:
```
User: holt forage --goal "Create recipe for spaghetti bolognese"
  ↓
GoalDefined artefact (by=user)
  ↓
Drafter bids "exclusive" → Creates recipe.yaml v1 (RecipeYAML artefact)
  ↓
Validator bids "review" → Finds vague instruction → Creates Review artefact (reject)
Formatter bids "claim" → Waits (review phase not complete)
  ↓
Orchestrator creates feedback claim (pending_assignment to Writer)
  ↓
Drafter receives feedback claim → Fixes recipe.yaml → Creates v2 (RecipeYAML artefact)
  ↓
Validator bids "review" → Finds good instructions → Creates Review artefact (approve)
Formatter bids "claim" → Waits (review phase not complete)
  ↓
Review approved → Formatter granted "claim" → Creates RECIPE.md
  ↓
Terminal artefact → Workflow complete
```

### **10.2. Demo Setup Instructions**

See `demos/recipe-generator/README.md` for complete setup instructions.

**Quick start**:
```bash
# Build demo images
make -f demos/recipe-generator/Makefile build-demo-recipe

# Create test workspace
mkdir /tmp/holt-recipe-demo && cd /tmp/holt-recipe-demo
git init && git commit --allow-empty -m "Initial commit"

# Initialize holt
holt init

# Copy demo config
cp <holt-repo>/demos/recipe-generator/holt.yml .

# Run demo
holt up
holt forage --watch --goal "Create a recipe for a classic spaghetti bolognese"

# Inspect results
holt hoard
cat RECIPE.md
git log --oneline
```

### **10.3. Expected Demo Output**

The demo should produce:
1. **recipe.yaml (v1)**: With deliberately short instruction "Cook."
2. **Review artefact**: With feedback about vague instruction
3. **Feedback claim**: Assigned to drafter (no bidding)
4. **recipe.yaml (v2)**: With improved instruction "Simmer sauce for 20 minutes."
5. **Review artefact**: With approval (empty payload "{}")
6. **RECIPE.md**: Formatted markdown version of recipe
7. **Git commits**: 3 commits (initial, v1, v2, formatted)

### **10.4. Demo Troubleshooting**

**Issue: Agents bidding on all artefacts**
- **Cause**: Missing jq in validator/formatter containers OR bid_script not being called
- **Fix**: Rebuild containers with jq: `RUN apk add jq` in Dockerfiles
- **Verify**: Check agent logs for bid decisions

**Issue: Infinite claim creation for Review artefacts**
- **Cause**: Pup not mapping artefact_type="Review" to StructuralTypeReview
- **Fix**: Implement structural type mapping in pup executor
- **Verify**: Check orchestrator logs - should see "claim_creation_skipped" for Review artefacts

**Issue: Drafter doesn't receive feedback**
- **Cause**: M3.3 feedback claim not being created
- **Fix**: Verify CheckReviewPhaseCompletion calls CreateFeedbackClaim
- **Verify**: Check orchestrator logs for "feedback_claim_created" event

**Issue: Formatter runs before approval**
- **Cause**: Bidding logic not checking for review feedback
- **Fix**: Formatter should bid "claim" not "exclusive" (runs in parallel phase after review)
- **Verify**: Formatter should wait until after validator approves

## **11. Self-validation checklist**

### **Before starting implementation:**

- [x] I understand M3.3 (automated feedback loop) is prerequisite
- [x] All success criteria (section 1.3) are measurable and testable
- [x] I have considered every component in section 2 explicitly
- [x] All design decisions (section 3.1) are justified and documented

### **During implementation:**

- [x] I am implementing bid script execution with proper error handling
- [ ] I am implementing structural type mapping to prevent claim loops
- [ ] I am testing bid script failures and fallback behavior
- [ ] I am verifying demo works end-to-end from clean state

### **Before submission:**

- [ ] All items in Definition of Done (section 5) are complete
- [ ] Demo has been tested in clean environment from scratch
- [ ] Documentation is updated and accurate (README, agent-development.md)
- [ ] I have tested all failure modes from section 6.1

---

**Status Summary**:
- ✅ Core dynamic bidding implemented (needs error handling enhancement)
- ✅ Config and CLI changes complete
- ⚠️ Structural type mapping needs implementation (critical bug fix)
- ⚠️ Config validation needs update (make bidding_strategy optional)
- ⚠️ Demo containers need jq installed (validator, formatter)
- 📝 Documentation needs completion (README, troubleshooting)
