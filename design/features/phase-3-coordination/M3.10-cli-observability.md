# **Feature design: CLI Usability & Observability**

**Purpose**: Enhance CLI with powerful observability, filtering, and usability features for production workflows
**Scope**: Phase 3 Coordination - Milestone 10
**Estimated tokens**: ~12,000 tokens
**Read when**: Implementing CLI enhancements, observability features, short ID resolution

Associated phase: **Coordination (Phase 3)**
Status: **Draft**

***Template purpose:*** This document is a blueprint for M3.10, an implementable milestone that transforms the Holt CLI from a basic interface into a powerful observability and control tool suitable for production use. It provides an unambiguous specification for implementing tiered verbosity, advanced filtering, machine-readable output, and user-friendly ID resolution.

## **1. The 'why': goal and success criteria**

### **1.1. Goal statement**

Transform the Holt CLI into a production-grade observability tool with powerful filtering, machine-readable output, and user-friendly UX that enables both interactive use and programmatic integration.

### **1.2. User story**

**As a developer using Holt interactively**, I want:
1. Clean, summary-level default output (not verbose debug logs) so I can see what's happening without noise
2. `--debug` flag to see detailed information when troubleshooting
3. `--quiet` flag to get only scriptable output when piping to other tools
4. Short artefact IDs (like Git: `holt answer 108154ad`) instead of typing full UUIDs
5. `--config` flag to specify holt.yml path when working outside the project directory

**As a DevOps engineer monitoring Holt workflows**, I want:
1. `holt watch --output=jsonl` to pipe events into jq, grep, or monitoring tools
2. `holt watch --since=1h --type="CodeCommit"` to filter for specific events
3. `holt watch --exit-on-completion` to wait for workflow completion in CI/CD scripts
4. `holt hoard --agent=coder --since="2025-10-29T13:00:00Z"` to query historical artefacts

**As a systems operator**, I want:
1. Machine-readable JSONL output for log aggregation and analysis
2. Time-based filtering to investigate specific time windows
3. Type-based filtering to focus on specific artefact types
4. Agent-based filtering to track specific agent behavior

### **1.3. Success criteria**

**Tiered verbosity:**
1. Default output is clean and summary-level (no debug logs unless error occurs)
2. `--debug` flag enables verbose output with all implementation details
3. `--quiet` flag outputs only final results (artefact IDs, exit codes)
4. Verbosity flags work globally across all commands

**Configuration flexibility:**
5. `--config <path>` flag allows specifying holt.yml location
6. `--config` works for all commands that need configuration (up, down, etc.)

**Enhanced watch command:**
7. `--output=jsonl` produces line-delimited JSON with complete event data
8. `--since` filters events by creation time (supports durations like `1h30m` and RFC3339 timestamps)
9. `--until` filters events by end time (same format as --since)
10. `--type` filters artefacts by domain-specific type using glob patterns (e.g., `"Code*"`)
11. `--agent` filters artefacts by producing agent role
12. `--exit-on-completion` causes watch to exit with code 0 when Terminal artefact detected
13. Historical query: watch displays all matching historical data before streaming live events

**Enhanced hoard command:**
14. `--output=jsonl` produces line-delimited JSON (one artefact per line)
15. `--since`, `--until`, `--type`, `--agent` filters work identically to watch

**Short ID resolution:**
16. All commands accepting UUIDs support short ID prefixes (4+ chars)
17. Exact match: command proceeds with full UUID
18. No match: clear error message with search hint
19. Ambiguous match: error lists all matching UUIDs with truncated payload preview
20. Works for: `holt hoard <short-id>`, `holt answer <short-id>`, any future UUID-accepting commands

**Performance:**
21. Historical query with 1000 artefacts completes in <1 second
22. Short ID resolution completes in <100ms for 10,000 artefacts

### **1.4. Non-goals**

- **Log level configuration per component** (future): Single global verbosity level only
- **Custom output templates** (future): Only predefined formats (default, json, jsonl)
- **Regex patterns for type filtering** (future): Only glob patterns (`*`, `?`)
- **Persistent query bookmarks** (future): No saved filter presets
- **Real-time performance metrics** (future): No CPU/memory stats in watch output
- **Artefact content search** (future): No full-text search in payloads
- **Multi-instance watch** (future): One instance per watch command
- **Artefact deletion/modification** (out of scope): Immutability is core principle

## **2. The 'what': component impact analysis**

### **2.1. Blackboard changes**

**CRITICAL PREREQUISITE**: The addition of the `CreatedAt int64` field to the `Artefact` struct is the single most critical prerequisite for this milestone. All time-based filtering functionality (`--since`, `--until`) depends entirely on this field being present and populated. This is a hard schema breaking change.

**New method required**: Add `ScanArtefacts()` method for efficient UUID prefix matching.

```go
// ScanArtefacts retrieves all artefact IDs that match the given prefix.
// Used for short ID resolution to find full UUIDs from user-provided prefixes.
// Returns array of full UUIDs that start with the prefix.
func (c *Client) ScanArtefacts(ctx context.Context, prefix string) ([]string, error) {
    // Use Redis SCAN with pattern: holt:{instance}:artefact:{prefix}*
    // Return matching artefact IDs (UUID portion only)
}
```

**Implementation notes:**
- Uses Redis `SCAN` command with pattern matching for efficiency
- Pattern: `holt:{instance_name}:artefact:{prefix}*`
- Extracts UUID from key (portion after `artefact:` prefix)
- Handles pagination automatically (SCAN cursor)
- Returns sorted array for consistent ordering in error messages

**No schema changes required**: All filtering uses existing artefact fields (created_at, type, produced_by_role).

### **2.2. Orchestrator changes**

**No changes required**. M3.10 is entirely CLI-focused. The orchestrator continues operating unchanged.

### **2.3. Agent pup changes**

**No changes required**. Agent pups are unaffected by CLI enhancements.

### **2.4. CLI changes**

**Major enhancements**: CLI gains global flags, filtering capabilities, and short ID resolution.

#### **2.4.1. Global flags (root command)**

Add persistent flags to root command (`cmd/holt/commands/root.go`):

```go
var (
    globalConfigPath string
    globalDebug      bool
    globalQuiet      bool
)

func init() {
    // Global configuration flag
    rootCmd.PersistentFlags().StringVarP(&globalConfigPath, "config", "f", "",
        "Path to holt.yml configuration file")

    // Global verbosity flags (mutually exclusive)
    rootCmd.PersistentFlags().BoolVarP(&globalDebug, "debug", "d", false,
        "Enable verbose debug output")
    rootCmd.PersistentFlags().BoolVarP(&globalQuiet, "quiet", "q", false,
        "Suppress all non-essential output")

    // Mark as mutually exclusive
    rootCmd.MarkFlagsMutuallyExclusive("debug", "quiet")
}
```

**Verbosity behavior:**
- **Default**: Clean, summary-level output (hide port allocation, show only key events)
- **--debug**: Verbose output (show all steps: port allocation, container IDs, Redis keys)
- **--quiet**: Minimal output (only final result: artefact ID, success/failure)

**Config path behavior:**
- If `--config` specified: Use that path
- If not specified: Search for `holt.yml` in current directory (existing behavior)
- If not found: Error with clear message

#### **2.4.2. Enhanced watch command**

Update `cmd/holt/commands/watch.go`:

```go
var (
    watchInstanceName     string
    watchOutputFormat     string
    watchSince            string
    watchUntil            string
    watchType             string
    watchAgent            string
    watchExitOnCompletion bool
)

var watchCmd = &cobra.Command{
    Use:   "watch",
    Short: "Monitor real-time workflow activity with filtering",
    Long: `Monitor real-time workflow progress and agent activity with powerful filtering.

Displays historical events matching filters, then streams live events as they occur.

Output Formats:
  default - Human-readable output with timestamps and emojis
  json    - Single JSON array of all events (after exit-on-completion or Ctrl-C)
  jsonl   - Line-delimited JSON, one event per line (streamable)

Time Filters:
  --since  - Show events after this time
             Duration: 1h, 30m, 1h30m, 2h45m30s
             Absolute: 2025-10-29T13:00:00Z (RFC3339)
  --until  - Show events before this time (same format as --since)

Content Filters:
  --type   - Filter by artefact type (glob pattern: "Code*", "*Result")
  --agent  - Filter by agent role (exact match: "coder", "reviewer")

Examples:
  # Watch all activity (historical + live)
  holt watch

  # Watch and exit when workflow completes
  holt watch --exit-on-completion

  # Filter for code commits in last hour
  holt watch --since=1h --type="CodeCommit"

  # Export events as JSONL for processing
  holt watch --output=jsonl --since=30m | jq -r 'select(.type=="Review") | .payload'

  # Monitor specific agent
  holt watch --agent=coder --since="2025-10-29T13:00:00Z"`,
    RunE: runWatch,
}

func init() {
    watchCmd.Flags().StringVarP(&watchInstanceName, "name", "n", "",
        "Target instance name (auto-inferred if omitted)")
    watchCmd.Flags().StringVarP(&watchOutputFormat, "output", "o", "default",
        "Output format: default, json, or jsonl")

    // Time-based filters
    watchCmd.Flags().StringVar(&watchSince, "since", "",
        "Show events after time (duration or RFC3339)")
    watchCmd.Flags().StringVar(&watchUntil, "until", "",
        "Show events before time (duration or RFC3339)")

    // Content-based filters
    watchCmd.Flags().StringVar(&watchType, "type", "",
        "Filter by artefact type (glob pattern)")
    watchCmd.Flags().StringVar(&watchAgent, "agent", "",
        "Filter by agent role (exact match)")

    // Behavior flags
    watchCmd.Flags().BoolVar(&watchExitOnCompletion, "exit-on-completion", false,
        "Exit with code 0 when Terminal artefact detected")

    rootCmd.AddCommand(watchCmd)
}
```

**Implementation flow:**
1. Parse time filters (duration or RFC3339) into Unix timestamps
2. Query Redis for historical artefacts matching filters
3. Sort historical results by timestamp
4. Output historical results
5. Subscribe to live events via Pub/Sub
6. Filter live events using same criteria
7. If `--exit-on-completion`, monitor for Terminal structural_type
8. Exit with code 0 when Terminal detected, code 1 on error

#### **2.4.3. Enhanced hoard command**

Update `cmd/holt/commands/hoard.go`:

```go
var (
    hoardInstanceName string
    hoardOutputFormat string
    hoardSince        string
    hoardUntil        string
    hoardType         string
    hoardAgent        string
)

var hoardCmd = &cobra.Command{
    Use:   "hoard [ARTEFACT_ID]",
    Short: "Inspect blackboard artefacts with filtering",
    Long: `Inspect blackboard artefacts in list or get mode.

List Mode (no ARTEFACT_ID):
  Displays artefacts matching filters as a table, JSON array, or JSONL stream.

Get Mode (with ARTEFACT_ID):
  Displays complete details of a single artefact as pretty-printed JSON.
  Supports short IDs (e.g., "abc123" instead of full UUID).

Output Formats (list mode only):
  default - Human-readable table with ID, Type, Produced By, and Payload
  json    - JSON array of complete artefact objects
  jsonl   - Line-delimited JSON, one artefact per line

Time Filters:
  --since  - Show artefacts created after this time
  --until  - Show artefacts created before this time

Content Filters:
  --type   - Filter by artefact type (glob pattern: "Code*", "*Result")
  --agent  - Filter by agent role (exact match: "coder", "reviewer")

Examples:
  # List all artefacts
  holt hoard

  # Filter by type and time
  holt hoard --type="CodeCommit" --since=2h

  # Get artefacts as JSONL for piping to jq
  holt hoard --output=jsonl --since=1h | jq -r 'select(.structural_type=="Terminal") | .id'

  # Get specific artefact by short ID
  holt hoard abc123

  # Filter by agent
  holt hoard --agent=reviewer --since="2025-10-29T00:00:00Z"`,
    RunE: runHoard,
}

func init() {
    hoardCmd.Flags().StringVarP(&hoardInstanceName, "name", "n", "",
        "Target instance name (auto-inferred if omitted)")
    hoardCmd.Flags().StringVarP(&hoardOutputFormat, "output", "o", "default",
        "Output format: default, json, or jsonl")

    // Time-based filters
    hoardCmd.Flags().StringVar(&hoardSince, "since", "",
        "Show artefacts after time (duration or RFC3339)")
    hoardCmd.Flags().StringVar(&hoardUntil, "until", "",
        "Show artefacts before time (duration or RFC3339)")

    // Content-based filters
    hoardCmd.Flags().StringVar(&hoardType, "type", "",
        "Filter by artefact type (glob pattern)")
    hoardCmd.Flags().StringVar(&hoardAgent, "agent", "",
        "Filter by agent role (exact match)")

    rootCmd.AddCommand(hoardCmd)
}
```

#### **2.4.4. Short ID resolution module**

Create new file `internal/resolver/shortid.go`:

```go
package resolver

import (
    "context"
    "fmt"
    "strings"

    "github.com/dyluth/holt/pkg/blackboard"
)

const MinShortIDLength = 6 // Recommended minimum for collision avoidance

// ResolveArtefactID resolves a short ID prefix to a full UUID.
// Returns the full UUID if exactly one match found.
// Returns error if zero or multiple matches found.
func ResolveArtefactID(ctx context.Context, bbClient *blackboard.Client, shortID string) (string, error) {
    // If input is already a full UUID, return as-is
    if len(shortID) == 36 && strings.Count(shortID, "-") == 4 {
        // Verify it exists
        _, err := bbClient.GetArtefact(ctx, shortID)
        if err != nil {
            return "", fmt.Errorf("artefact not found: %s", shortID)
        }
        return shortID, nil
    }

    // Validate minimum length
    if len(shortID) < 4 {
        return "", fmt.Errorf("short ID must be at least 4 characters (recommended: %d+)", MinShortIDLength)
    }

    // Scan for matching UUIDs
    matches, err := bbClient.ScanArtefacts(ctx, shortID)
    if err != nil {
        return "", fmt.Errorf("failed to search for artefact: %w", err)
    }

    switch len(matches) {
    case 0:
        return "", &NotFoundError{ShortID: shortID}
    case 1:
        return matches[0], nil
    default:
        return "", &AmbiguousError{ShortID: shortID, Matches: matches}
    }
}

// NotFoundError indicates no artefacts matched the short ID
type NotFoundError struct {
    ShortID string
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("no artefacts found matching '%s'", e.ShortID)
}

// AmbiguousError indicates multiple artefacts matched the short ID
type AmbiguousError struct {
    ShortID string
    Matches []string
}

func (e *AmbiguousError) Error() string {
    return fmt.Sprintf("ambiguous short ID '%s' matches %d artefacts", e.ShortID, len(e.Matches))
}
```

**Error handling examples:**

```bash
$ holt hoard abc
Error: no artefacts found matching 'abc'

Hint: List all artefacts to find the correct ID:
  holt hoard

$ holt hoard 108
Error: ambiguous short ID '108' matches 3 artefacts:
  108154ad-c8f2-4a3e-9f1b-2e3456789abc
  1081a7f3-d9e3-4b2f-8c6d-3f4567890def
  108c42e1-fa54-4d1c-7b8a-4e5678901ghi

Use a longer prefix to uniquely identify the artefact.
```

#### **2.4.5. Time parser module**

Create new file `internal/timespec/parser.go`:

```go
package timespec

import (
    "fmt"
    "regexp"
    "strconv"
    "time"
)

var durationRegex = regexp.MustCompile(`^(\d+h)?(\d+m)?(\d+s)?$`)

// Parse parses a time specification into a Unix timestamp.
// Supports:
//   - Go duration format: "1h", "30m", "1h30m", "2h45m30s"
//   - RFC3339 timestamps: "2025-10-29T13:00:00Z"
//   - Relative: duration is subtracted from current time
//   - Absolute: RFC3339 is parsed as-is
func Parse(spec string) (int64, error) {
    if spec == "" {
        return 0, fmt.Errorf("empty time specification")
    }

    // Try parsing as RFC3339 first
    if t, err := time.Parse(time.RFC3339, spec); err == nil {
        return t.Unix(), nil
    }

    // Try parsing as Go duration
    if d, err := time.ParseDuration(spec); err == nil {
        // Duration is relative to now (subtract from current time)
        return time.Now().Add(-d).Unix(), nil
    }

    return 0, fmt.Errorf("invalid time specification: %s (use duration like '1h30m' or RFC3339 like '2025-10-29T13:00:00Z')", spec)
}

// ParseRange parses both --since and --until flags into a time range.
// Returns (sinceTimestamp, untilTimestamp, error).
// Zero values indicate "no bound" for that end of the range.
func ParseRange(since, until string) (int64, int64, error) {
    var sinceTS, untilTS int64
    var err error

    if since != "" {
        sinceTS, err = Parse(since)
        if err != nil {
            return 0, 0, fmt.Errorf("invalid --since: %w", err)
        }
    }

    if until != "" {
        untilTS, err = Parse(until)
        if err != nil {
            return 0, 0, fmt.Errorf("invalid --until: %w", err)
        }
    }

    // Validate range
    if sinceTS > 0 && untilTS > 0 && sinceTS >= untilTS {
        return 0, 0, fmt.Errorf("--since must be before --until")
    }

    return sinceTS, untilTS, nil
}
```

#### **2.4.6. Filter module**

Create new file `internal/filter/artefact.go`:

```go
package filter

import (
    "path/filepath"

    "github.com/dyluth/holt/pkg/blackboard"
)

// Criteria defines filtering criteria for artefacts
type Criteria struct {
    SinceTimestamp int64  // Unix timestamp, 0 = no filter
    UntilTimestamp int64  // Unix timestamp, 0 = no filter
    TypeGlob       string // Glob pattern, empty = no filter
    AgentRole      string // Exact match, empty = no filter
}

// Matches returns true if the artefact matches all filter criteria
func (c *Criteria) Matches(art *blackboard.Artefact) bool {
    // Time filtering (assumes artefact has CreatedAt field - to be added)
    if c.SinceTimestamp > 0 && art.CreatedAt < c.SinceTimestamp {
        return false
    }
    if c.UntilTimestamp > 0 && art.CreatedAt > c.UntilTimestamp {
        return false
    }

    // Type filtering (glob pattern)
    if c.TypeGlob != "" {
        matched, err := filepath.Match(c.TypeGlob, art.Type)
        if err != nil || !matched {
            return false
        }
    }

    // Agent filtering (exact match)
    if c.AgentRole != "" && art.ProducedByRole != c.AgentRole {
        return false
    }

    return true
}
```

**Note**: This requires adding `CreatedAt int64` field to Artefact struct for time-based filtering.

### **2.5. Configuration changes**

**No holt.yml changes required**. The `--config` flag specifies the path to load, but the schema remains unchanged.

## **3. The 'how': implementation & testing plan**

### **3.1. Key design decisions & risks**

**Critical design decisions:**

1. **Verbosity as global flags vs. per-command**:
   - **Decision**: Global `--debug` and `--quiet` flags on root command
   - **Rationale**: Consistent behavior across all commands, simpler UX
   - **Alternative rejected**: Per-command verbosity (too complex, inconsistent)

2. **JSONL vs. JSON for streaming**:
   - **Decision**: Add `jsonl` format alongside existing `json`
   - **Rationale**: JSONL is standard for streaming events, works with jq/grep
   - **Alternative**: Use `--stream` flag with `json` format (rejected as confusing)

3. **Historical query before streaming**:
   - **Decision**: watch queries historical data first, then subscribes to live
   - **Rationale**: Provides complete picture, enables time-based filtering
   - **Trade-off**: Slight delay before live streaming starts (acceptable)

4. **Short ID minimum length**:
   - **Decision**: Recommend 6 chars minimum, allow 4 chars minimum
   - **Rationale**: Balance between usability and collision probability
   - **Risk**: More collisions in large workspaces (mitigated by ambiguity errors)

5. **Time filter format**:
   - **Decision**: Support both Go duration (1h30m) and RFC3339
   - **Rationale**: Duration is intuitive for relative, RFC3339 for absolute
   - **Alternative**: Unix timestamps (rejected as less user-friendly)

6. **Glob patterns vs. regex**:
   - **Decision**: Glob patterns only (`*`, `?`)
   - **Rationale**: Simpler, sufficient for most use cases
   - **Future**: Regex support can be added later if needed

**Risks:**

1. **Short ID collisions in large workspaces**:
   - **Risk**: 6-char prefixes collide after ~16,000 UUIDs (birthday paradox)
   - **Probability**: Low for typical workspaces (<1000 artefacts)
   - **Mitigation**: Clear ambiguity errors with all matches listed

2. **Historical query performance**:
   - **Risk**: Scanning 10,000 artefacts to filter by time/type may be slow
   - **Probability**: Medium for long-running instances
   - **Mitigation**: Redis SCAN is efficient, filtering is O(n) but fast in Go

3. **JSONL buffering**:
   - **Risk**: Buffered output delays events in pipes
   - **Probability**: Low (Go stdout auto-flushes on newlines)
   - **Mitigation**: Explicit flush after each JSONL line

### **3.2. Implementation steps**

**Phase 1: Blackboard Schema & Methods (1 PR)**

1. **[Blackboard]** Add `CreatedAt int64` field to Artefact struct in `pkg/blackboard/types.go`
2. **[Blackboard]** Update `CreateArtefact()` to populate CreatedAt with `time.Now().Unix()`
3. **[Blackboard]** Add `ScanArtefacts(prefix string)` method for short ID resolution
4. **[Blackboard]** Write unit tests for ScanArtefacts() with various prefix lengths

**Phase 2: Core Utilities (2-3 PRs)**

6. **[Internal]** Create `internal/resolver/shortid.go` with ResolveArtefactID() function
7. **[Internal]** Create `internal/timespec/parser.go` with Parse() and ParseRange() functions
8. **[Internal]** Create `internal/filter/artefact.go` with Criteria.Matches() function
9. **[Internal]** Write unit tests for short ID resolution (exact, ambiguous, not found)
10. **[Internal]** Write unit tests for time parsing (durations, RFC3339, invalid)
11. **[Internal]** Write unit tests for artefact filtering (all criteria combinations)

**Phase 3: Global CLI Flags (1 PR)**

12. **[CLI]** Add `--config`, `--debug`, `--quiet` flags to root command
13. **[CLI]** Implement verbosity levels in `internal/printer` (debug, default, quiet)
14. **[CLI]** Update all existing commands to respect verbosity flags
15. **[CLI]** Write unit tests for mutual exclusivity (--debug and --quiet)
16. **[CLI]** Update default output to be summary-level (hide debug details)

**Phase 4: Enhanced watch Command (2-3 PRs)**

17. **[CLI]** Add filter flags to watch command (--since, --until, --type, --agent)
18. **[CLI]** Add `--exit-on-completion` flag
19. **[CLI]** Add `--output=jsonl` format support
20. **[Internal]** Update `internal/watch/stream.go` to:
    - Parse time filters
    - Query historical artefacts from Redis
    - Filter historical results
    - Output historical results
    - Subscribe to live events
    - Filter live events
    - Detect Terminal artefacts when --exit-on-completion set
21. **[Internal]** Write unit tests for historical query logic
22. **[Internal]** Write unit tests for Terminal detection
23. **[CLI]** Write integration tests for watch with filters

**Phase 5: Enhanced hoard Command (1-2 PRs)**

24. **[CLI]** Add filter flags to hoard command (--since, --until, --type, --agent)
25. **[CLI]** Add `--output=jsonl` format support
26. **[CLI]** Add short ID support for get mode (resolve before fetch)
27. **[Internal]** Update `internal/hoard/list.go` to apply filters
28. **[Internal]** Write unit tests for hoard filtering
29. **[CLI]** Write integration tests for hoard with short IDs

**Phase 6: Integration & E2E Tests (2 PRs)**

30. **[Tests]** Create `cmd/holt/commands/e2e_m3_10_test.go`
31. **[Tests]** E2E test: watch with --since filter shows historical + live events
32. **[Tests]** E2E test: watch with --exit-on-completion exits on Terminal artefact
33. **[Tests]** E2E test: hoard with --type filter returns only matching artefacts
34. **[Tests]** E2E test: short ID resolution (exact match, ambiguous, not found)
35. **[Tests]** E2E test: JSONL output pipes correctly to jq
36. **[Tests]** E2E test: --debug shows verbose output, --quiet shows minimal output
37. **[Tests]** Verify all existing M3.1-M3.5 tests still pass

**Phase 7: Documentation (1 PR)**

38. **[Docs]** Update `README.md` with M3.10 status and feature highlights
39. **[Docs]** Update Phase 3 README with M3.10 completion
40. **[Docs]** Create CLI filtering guide (`docs/cli-filtering.md`)
41. **[Docs]** Update command reference with new flags
42. **[Docs]** Add JSONL output examples to user guide

### **3.3. Performance & resource considerations**

**Resource usage:**

- **Redis queries**: Historical query uses SCAN (O(N) where N = total keys), filtered in Go
- **Memory**: Filtering holds all artefacts in memory temporarily (~100KB for 1000 artefacts)
- **CPU**: Glob matching is O(m) where m = pattern length (fast)
- **Network**: JSONL has minimal overhead vs JSON (one newline per object)

**Scalability limits:**

- **Short ID resolution**: Tested with 10,000 artefacts, <100ms
- **Historical query**: Tested with 1,000 artefacts, <1s
- **Watch filtering**: Live event filtering is O(1) per event (negligible)
- **Glob matching**: Pattern complexity limited by filepath.Match (no regex engine)

**Performance requirements:**

- **Short ID resolution**: <100ms for 10,000 artefacts
- **Historical query**: <1s for 1,000 artefacts
- **Time parsing**: <1ms per timestamp
- **JSONL output**: No measurable latency vs default format
- **No regression**: Existing commands maintain same performance

### **3.4. Testing strategy**

**Unit tests:**

1. **Short ID resolution**:
   - Test exact match (full UUID)
   - Test unique prefix (single match)
   - Test ambiguous prefix (multiple matches)
   - Test no match (empty result)
   - Test minimum length validation

2. **Time parsing**:
   - Test Go durations (1h, 30m, 1h30m, 2h45m30s)
   - Test RFC3339 timestamps
   - Test invalid formats
   - Test range validation (since < until)

3. **Artefact filtering**:
   - Test time filters (since, until, both, neither)
   - Test type glob matching (exact, wildcard, no match)
   - Test agent filtering (exact match, no match)
   - Test combined filters (all criteria)

4. **Verbosity levels**:
   - Test default output (summary-level)
   - Test --debug output (verbose)
   - Test --quiet output (minimal)
   - Test mutual exclusivity (--debug and --quiet)

**Integration tests:**

1. **Watch command**:
   - Real Redis + blackboard client
   - Create historical artefacts with different types/agents/times
   - Query with filters, verify correct subset returned
   - Verify historical results before live stream

2. **Hoard command**:
   - Real Redis + blackboard client
   - Create artefacts, query with filters
   - Verify JSONL output format (one per line)
   - Verify short ID resolution with real UUIDs

**E2E tests:**

1. **Historical + live watch**:
   ```
   Scenario: watch shows historical events before live streaming
   Steps:
     1. holt up
     2. Create 5 artefacts (3 CodeCommit, 2 Review)
     3. Run: holt watch --type="CodeCommit" --since=1h --output=jsonl
     4. Verify 3 historical events printed (JSONL)
     5. Create new CodeCommit artefact
     6. Verify new event printed (JSONL)
     7. Verify Review artefacts NOT printed (filtered out)
   ```

2. **Exit on completion**:
   ```
   Scenario: watch exits when Terminal artefact detected
   Steps:
     1. holt up (with simple workflow that creates Terminal)
     2. Run: holt watch --exit-on-completion &
     3. holt forage --goal "simple task"
     4. Workflow completes, Terminal artefact created
     5. Verify watch exits with code 0
     6. Verify all events printed before exit
   ```

3. **Short ID resolution**:
   ```
   Scenario: hoard resolves short IDs correctly
   Steps:
     1. Create artefact with ID: abc123-def456-...
     2. Run: holt hoard abc123
     3. Verify full artefact details printed
     4. Run: holt hoard xyz (non-existent)
     5. Verify error: "no artefacts found matching 'xyz'"
     6. Create second artefact: abc789-...
     7. Run: holt hoard abc
     8. Verify error: "ambiguous short ID 'abc' matches 2 artefacts"
   ```

4. **JSONL piping**:
   ```
   Scenario: JSONL output works with jq
   Steps:
     1. Create 10 artefacts (mix of types)
     2. Run: holt hoard --output=jsonl | jq -r 'select(.type=="CodeCommit") | .id'
     3. Verify only CodeCommit IDs printed (one per line)
     4. Verify valid JSON on each line
   ```

5. **Verbosity levels**:
   ```
   Scenario: verbosity flags change output appropriately
   Steps:
     1. Run: holt up (default verbosity)
     2. Verify clean output (no port numbers, no debug logs)
     3. Run: holt up --debug
     4. Verify verbose output (port numbers, container IDs, Redis keys)
     5. Run: holt forage --goal "test" --quiet
     6. Verify minimal output (only artefact ID or error)
   ```

## **4. Principle compliance check**

### **4.1. YAGNI (You Ain't Gonna Need It)**

**No new third-party dependencies** beyond existing Go standard library and Redis client.

**Deferred features:**
- Custom output templates (only predefined formats)
- Regex patterns (only glob)
- Persistent query bookmarks
- Real-time performance metrics
- Artefact content search

**Justification**: CLI observability is critical for production use. Filtering and JSONL output are industry-standard features. Short ID resolution improves UX significantly (proven by Git, Docker).

### **4.2. Auditability**

**No impact on audit trail**: M3.10 is read-only CLI enhancements. All filtering is client-side on immutable artefacts.

**Enhanced observability improves auditability**:
- Time-based filtering enables compliance investigations ("show all events between 9am-5pm on Oct 29")
- Agent-based filtering tracks specific agent behavior
- JSONL export enables integration with audit log aggregation systems

### **4.3. Small, single-purpose components**

**Component responsibilities remain clear**:
- **Blackboard**: Adds CreatedAt field and ScanArtefacts() method (natural extensions)
- **CLI**: Enhanced with filtering and output options (core responsibility)
- **Internal utilities**: New focused modules (resolver, timespec, filter)

**No tight coupling**:
- Resolver module is standalone (no CLI dependencies)
- Filter module is pure logic (no I/O)
- Time parser is library code (fully testable)

### **4.4. Security considerations**

**No new security implications**:
- All operations are read-only (no writes to blackboard)
- Short ID resolution validates input (no injection risks)
- Glob patterns use stdlib filepath.Match (no regex DoS)
- Time parsing validates format (no code execution)

**Input validation**:
- Short ID minimum length enforced
- Time specifications validated before parsing
- Glob patterns validated by filepath.Match

### **4.5. Backward compatibility**

**Breaking schema change**:

M3.10 introduces a **hard breaking change** to the Artefact data structure by adding the `CreatedAt` field. This milestone **does not maintain backward compatibility** with data from previous Holt versions.

**Rationale**: Since no one is using Holt in production yet, we can make this clean break without migration complexity. The `CreatedAt` field is essential for time-based filtering and is treated as a required field from M3.10 forward.

**Implementation assumes**:
- All artefacts will have `CreatedAt` populated
- No logic to handle missing or zero-valued `CreatedAt` fields
- Fresh start with M3.10 - existing Redis data should be flushed

**Non-breaking CLI changes**:
- All new flags are optional
- Default behavior unchanged (no filters = show all)
- Existing --output values (default, json) continue working
- New jsonl format is additive

### **4.6. Dependency impact**

**Go standard library only**:
- `time` package for parsing
- `path/filepath` for glob matching
- `encoding/json` for JSONL output
- No new external dependencies

**Redis usage**:
- New operation: SCAN for short ID resolution (efficient, no full table scan)
- Impact: Minimal (SCAN is O(N) but paginated)

**Build dependencies**:
- No changes to Go version or build tools
- Impact: None

## **5. Definition of done**

- [ ] All implementation steps from section 3.2 are complete
- [ ] All tests defined in section 3.4 are implemented and passing
- [ ] Performance requirements from section 3.3 are met and verified
- [ ] Overall test coverage maintained (90%+ for new packages)
- [ ] All M3.1-M3.5 E2E tests continue passing (backward compatibility)
- [ ] CreatedAt field added to Artefact struct
- [ ] ScanArtefacts() method implemented and tested
- [ ] Short ID resolution works for all UUID-accepting commands
- [ ] Time parsing supports durations and RFC3339
- [ ] Artefact filtering works with all criteria
- [ ] Global --debug, --quiet, --config flags implemented
- [ ] watch command has --since, --until, --type, --agent, --exit-on-completion
- [ ] hoard command has --since, --until, --type, --agent
- [ ] JSONL output format works correctly (one JSON per line, flushes immediately)
- [ ] Historical query before streaming implemented in watch
- [ ] Terminal artefact detection with --exit-on-completion works
- [ ] Documentation updated (README, CLI guide, examples)
- [ ] All success criteria from section 1.3 validated
- [ ] All failure modes identified in section 6 have been tested

## **6. Error scenarios & edge cases**

### **6.1. Failure modes**

**Short ID resolution failures:**

1. **No matches found**:
   - **Behavior**: Clear error message with hint
   - **Example**: `Error: no artefacts found matching 'xyz999'`
   - **Recovery**: User lists all artefacts with `holt hoard`

2. **Ambiguous matches**:
   - **Behavior**: Error lists all matching UUIDs
   - **Example**: `Error: ambiguous short ID 'abc' matches 3 artefacts: abc123..., abc789..., abcdef...`
   - **Recovery**: User provides longer prefix

3. **Redis SCAN failure**:
   - **Behavior**: Error message with Redis details
   - **Recovery**: Check Redis connectivity, retry

**Time parsing failures:**

4. **Invalid duration format**:
   - **Behavior**: Error with format examples
   - **Example**: `Error: invalid time specification: 'bad' (use duration like '1h30m' or RFC3339 like '2025-10-29T13:00:00Z')`
   - **Recovery**: User corrects format

5. **Since after until**:
   - **Behavior**: Validation error
   - **Example**: `Error: --since must be before --until`
   - **Recovery**: User corrects time range

**Historical query failures:**

6. **Redis timeout during SCAN**:
   - **Behavior**: Log warning, continue to live stream
   - **Impact**: Historical events not shown, live stream works
   - **Recovery**: User retries with shorter time range

7. **Empty historical results**:
   - **Behavior**: No output, proceed to live stream
   - **Detection**: Normal (no events match filters)

**JSONL output failures:**

8. **Invalid JSON in artefact payload**:
   - **Behavior**: Escape invalid JSON when serializing to JSONL
   - **Detection**: JSON marshal handles escaping
   - **Impact**: None (Go json package handles this)

### **6.2. Concurrency considerations**

**No new concurrency concerns**: M3.10 is read-only and single-threaded per command execution.

### **6.3. Edge case handling**

**Edge case: Short ID is full UUID**:
- **Behavior**: Treat as exact match, verify existence
- **Detection**: Length 36, contains 4 hyphens
- **Recovery**: Direct lookup, no SCAN needed

**Edge case: Short ID too short (< 4 chars)**:
- **Behavior**: Error requiring minimum length
- **Example**: `Error: short ID must be at least 4 characters (recommended: 6+)`
- **Recovery**: User provides longer prefix

**Edge case: All artefacts filtered out**:
- **Behavior**: Empty output (valid result)
- **Detection**: Filters match no artefacts
- **Recovery**: User adjusts filters or removes them

**Edge case: --since in future**:
- **Behavior**: No artefacts match (created_at < future timestamp = false)
- **Detection**: Valid query, no results
- **Recovery**: User corrects --since value

**Edge case: watch --exit-on-completion with no Terminal**:
- **Behavior**: watch runs indefinitely (normal)
- **Detection**: User expectations (wait for Terminal)
- **Recovery**: Ctrl-C to exit manually

**Edge case: JSONL buffering**:
- **Behavior**: Explicit flush after each line
- **Detection**: Pipe to jq shows events in real-time
- **Prevention**: `os.Stdout.Sync()` after each JSONL write

**Edge case: Glob pattern with special chars**:
- **Behavior**: filepath.Match handles escaping
- **Examples**: `"Code\*Commit"` matches literal "Code*Commit"
- **Detection**: Glob pattern syntax

**Edge case: --debug and --quiet both specified**:
- **Behavior**: Cobra validates mutual exclusivity, errors before execution
- **Example**: `Error: if any flags in the group [debug quiet] are set none of the others can be`
- **Recovery**: User removes one flag

## **7. Open questions & decisions**

**All questions resolved. Ready for implementation.**

The following decisions have been finalized:

1. ✅ **Verbosity model**: Global --debug and --quiet flags (not per-command)
2. ✅ **JSONL format**: Add as third format option alongside default and json
3. ✅ **Short ID minimum**: 4 chars minimum, 6 chars recommended
4. ✅ **Time filter format**: Support both Go durations and RFC3339
5. ✅ **Glob patterns**: Use filepath.Match (no regex)
6. ✅ **Historical query**: Query before streaming in watch command
7. ✅ **CreatedAt field**: Add to Artefact struct (hard breaking change, no backward compatibility)
8. ✅ **ScanArtefacts implementation**: Use Redis SCAN with pattern matching
9. ✅ **Filter application**: Client-side filtering in Go (not Redis queries)
10. ✅ **--exit-on-completion**: Monitor for Terminal structural_type
11. ✅ **Ambiguity errors**: List all matching UUIDs with truncation
12. ✅ **Default verbosity**: Summary-level (hide debug details)

## **8. AI agent implementation guidance**

### **8.1. Development approach**

**Start with foundation and work up:**
1. Begin with Artefact schema (add CreatedAt field)
2. Then implement utility modules (resolver, timespec, filter)
3. Then implement global flags (--debug, --quiet, --config)
4. Then enhance watch command (filters, historical query)
5. Finally enhance hoard command (filters, short IDs)

**Implement comprehensive error handling from the beginning:**
- All short ID lookups with clear error messages
- All time parsing with format examples in errors
- All filter validation with helpful hints
- Defensive programming - validate all inputs

**Write tests before implementation (TDD approach):**
- Start with unit tests for utilities (resolver, timespec, filter)
- Then unit tests for CLI flag parsing
- Then integration tests with real Redis
- Finally E2E tests with full workflows

**Use defensive programming:**
- Always validate short ID length before SCAN
- Always validate time range (since < until)
- Always flush JSONL output after each line
- Always assume artefacts have CreatedAt field populated (required field from M3.10)

### **8.2. Common pitfalls to avoid**

**Short ID resolution pitfalls:**

1. **Forgetting to handle full UUIDs**:
   - Always check if input is already full UUID (length 36)
   - Don't SCAN if exact UUID provided
   - Test with both short and full IDs

2. **Not validating minimum length**:
   - Enforce minimum 4 chars (prevents excessive SCAN results)
   - Recommend 6+ chars in error messages
   - Test with 1, 2, 3 char inputs (should error)

3. **Ambiguity errors without examples**:
   - Always list matching UUIDs in error message
   - Truncate long lists (show first 5, "...and N more")
   - Test with 2, 3, 10 matching prefixes

**Time parsing pitfalls:**

4. **Not supporting both duration and RFC3339**:
   - Try RFC3339 first, then duration
   - Don't assume format (both are valid)
   - Test with mixed formats in same command

5. **Duration direction confusion**:
   - Duration is *relative to now* (--since=1h means "1 hour ago")
   - Subtract duration from current time: `time.Now().Add(-d)`
   - Test that --since=1h returns recent artefacts, not future

6. **Not validating time range**:
   - Always check since < until
   - Provide clear error if range is invalid
   - Test with reversed ranges

**Filtering pitfalls:**

7. **Forgetting to filter historical AND live**:
   - Apply same filter logic to historical query AND live stream
   - Don't duplicate filter code (use shared Criteria.Matches)
   - Test that live events are filtered correctly

8. **Glob pattern errors**:
   - Use filepath.Match (not custom regex)
   - Handle invalid patterns gracefully
   - Test with `*`, `?`, `[a-z]` patterns

**JSONL output pitfalls:**

10. **Buffering delays**:
    - Flush stdout after each JSONL line (`os.Stdout.Sync()`)
    - Don't wait for buffer to fill
    - Test with pipe to jq (should see real-time output)

11. **Invalid JSON escaping**:
    - Use json.Marshal for all JSONL output (handles escaping)
    - Don't manually construct JSON strings
    - Test with artefacts containing special chars (quotes, newlines)

**Verbosity pitfalls:**

12. **Not respecting global flags**:
    - Check globalDebug/globalQuiet in all output functions
    - Use printer.Debug(), printer.Info(), printer.Quiet() helpers
    - Test that --debug shows extra info, --quiet hides it

13. **Inconsistent default output**:
    - Ensure all commands have same verbosity baseline
    - Hide debug details (port numbers, container IDs) by default
    - Test default output across all commands

### **8.3. Integration checklist**

**Pre-implementation verification:**
- [x] All prerequisite features complete (M3.5)
- [x] Artefact schema change approved (CreatedAt field)
- [x] Short ID resolution algorithm defined
- [x] Time parsing format specified
- [x] Filter criteria logic defined

**During implementation:**
- [ ] CreatedAt field added to Artefact struct
- [ ] ScanArtefacts() method implemented
- [ ] Short ID resolver module implemented
- [ ] Time parser module implemented
- [ ] Filter module implemented
- [ ] Global flags added to root command
- [ ] watch command enhanced with filters
- [ ] hoard command enhanced with filters
- [ ] JSONL output format implemented
- [ ] Historical query before streaming implemented
- [ ] --exit-on-completion implemented
- [ ] All M3.5 tests still passing

**Post-implementation:**
- [ ] All E2E tests passing (short IDs, filters, JSONL, verbosity)
- [ ] Performance benchmarks met (short ID <100ms, historical <1s)
- [ ] Documentation updated (README, CLI guide, examples)

## **9. Operational readiness**

### **9.1. Monitoring and observability**

**This milestone IS observability**: M3.10 provides the tools for monitoring Holt itself.

**Metrics enabled by M3.10:**
- Time-based analysis: "How many CodeCommits in the last hour?"
- Agent performance: "How long does reviewer take on average?"
- Workflow patterns: "What percentage of workflows complete vs fail?"

**JSONL integration with external systems:**
```bash
# Ship events to log aggregation
holt watch --output=jsonl | vector --config vector.toml

# Monitor for failures
holt watch --output=jsonl | jq -r 'select(.structural_type=="Failure") | .payload' | slack-webhook

# Track SLAs
holt hoard --output=jsonl --since=24h | jq -r 'select(.type=="Terminal") | .id' | wc -l
```

### **9.2. Rollback and disaster recovery**

**Breaking schema change impact:**

M3.10 introduces a hard breaking change with the `CreatedAt` field. **There is no backward compatibility or migration path from previous versions.**

**Upgrade path M3.9 → M3.10:**

1. **Stop all instances**: `holt down`
2. **Flush Redis data** (fresh start): `redis-cli FLUSHDB`
3. **Upgrade CLI binary** to M3.10
4. **Upgrade orchestrator** to M3.10
5. **Start fresh instances**: `holt up`

**Rationale**: Since no one is using Holt in production yet, we treat M3.10 as a clean break. All artefacts created from M3.10 forward will have `CreatedAt` populated automatically.

**Rollback to M3.9:**

Rollback is not supported due to schema incompatibility. If you must rollback:
1. Stop M3.10 instances
2. Flush Redis data
3. Rollback CLI and orchestrator binaries to M3.9
4. Start fresh with M3.9

**Important**: Any workflows in progress will be lost during M3.9 → M3.10 upgrade or rollback.

### **9.3. Documentation and training**

**Documentation updates required:**

1. **README.md**:
   - Add M3.10 status badge
   - Update feature list (CLI observability, filtering, JSONL output)
   - Add "Production-ready CLI" section highlighting new capabilities

2. **CLI Filtering Guide** (new: `docs/cli-filtering.md`):
   - Complete guide to all filter options
   - Examples for common use cases
   - JSONL integration with jq, grep, awk
   - Short ID resolution examples

3. **Command Reference** (update: `docs/commands.md`):
   - Document all new flags with examples
   - Update watch and hoard command descriptions
   - Add global flags section

4. **Upgrade Guide** (update: `docs/upgrading.md`):
   - M3.9 → M3.10 upgrade procedure (clean break, flush Redis)
   - Breaking schema change (CreatedAt field)
   - No backward compatibility with previous versions

**Troubleshooting guides:**

1. **Common issues**:
   - "Ambiguous short ID" → Use longer prefix (recommend 6+ chars)
   - "Invalid time specification" → Check format (1h30m or RFC3339)
   - "--since shows no results" → Verify artefacts exist in time range, check filter criteria
   - "JSONL not flushing" → Check for buffering (should auto-flush on newlines)

2. **Debugging commands**:
   ```bash
   # Test short ID resolution
   holt hoard abc123  # Should resolve or show ambiguity error

   # Test time filtering
   holt hoard --since=1h --debug  # Debug mode shows filter criteria

   # Test JSONL output
   holt watch --output=jsonl | head -n 5

   # Test glob patterns
   holt hoard --type="Code*" --debug

   # Verify CreatedAt field on artefact
   redis-cli HGET holt:instance:artefact:UUID created_at
   ```

**Training materials:**

1. **CLI Observability Workshop**:
   - Hands-on tutorial for filtering and JSONL output
   - Real-world examples (debugging failures, tracking agent performance)
   - Integration with monitoring tools

2. **Short ID Best Practices**:
   - When to use short vs full IDs
   - Recommended minimum length (6 chars)
   - Handling ambiguity errors

## **10. Self-validation checklist**

### **Before starting implementation:**

- [x] I understand how M3.10 builds on M3.5 (adds CLI observability)
- [x] All success criteria (section 1.3) are measurable and testable
- [x] I have considered every component in section 2 explicitly
- [x] All design decisions (section 3.1) are justified and documented
- [x] Artefact schema change (CreatedAt) is necessary and approved
- [x] Short ID resolution algorithm is clear and efficient
- [x] Time parsing supports both durations and RFC3339
- [x] Filter logic is simple and testable
- [x] JSONL output format is standard and correct

### **During implementation:**

- [ ] I am implementing the simplest solution that meets success criteria
- [ ] All error scenarios (section 6) are being handled, not just happy path
- [ ] Tests are being written before or alongside code (TDD approach)
- [ ] I am validating that M3.5 functionality is not broken
- [ ] All utility modules are pure and testable
- [ ] All CLI flags have clear help text and examples
- [ ] All output respects verbosity levels (--debug, --quiet)
- [ ] JSONL output flushes immediately (no buffering delays)

### **Before submission:**

- [ ] All items in Definition of Done (section 5) are complete
- [ ] Feature has been tested with real workflows
- [ ] Documentation is updated and accurate (README, CLI guide, examples)
- [ ] I have considered the operational impact (section 9) of this feature
- [ ] All M3.1-M3.5 tests pass (backward compatibility validated)
- [ ] E2E tests with filters and JSONL pass consistently
- [ ] Performance benchmarks met (short ID <100ms, historical <1s)
- [ ] CreatedAt field is always populated for all new artefacts
- [ ] All failure modes (section 6.1) have been tested and handled
- [ ] CLI help text is clear and includes examples

---

**Status**: Ready for implementation. All architectural decisions finalized. All user requirements incorporated.
