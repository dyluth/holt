#!/bin/sh
# TerraformDrafter agent - Generates Terraform code from user goal
# DUAL-MODE: Uses OpenAI API if OPENAI_API_KEY set, otherwise uses mocked responses

set -e

input=$(cat)
cd /workspace

# Configure git user for commits
git config user.email "terraformdrafter@holt.demo"
git config user.name "Holt TerraformDrafter"

# Capture original branch to preserve user's workspace state
original_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

# Extract goal and context from input
goal=$(echo "$input" | jq -r '.target_artefact.payload')
context_chain=$(echo "$input" | jq -r '.context_chain')

echo "TerraformDrafter: Received goal: $goal" >&2

# Check if this is a rework (review feedback present in context)
has_review_feedback=false
review_feedback=""
if echo "$context_chain" | jq -e '.[] | select(.structural_type == "Review")' > /dev/null 2>&1; then
    has_review_feedback=true
    review_feedback=$(echo "$context_chain" | jq -r '.[] | select(.structural_type == "Review") | .payload')
    echo "TerraformDrafter: Rework requested - review feedback received" >&2
    echo "TerraformDrafter: Feedback: $review_feedback" >&2
fi

# Determine mode: OpenAI API or mocked
if [ -n "$OPENAI_API_KEY" ]; then
    echo "TerraformDrafter: Using OpenAI API (gpt-4o-mini)" >&2

    # Build prompt based on whether this is first attempt or rework
    if [ "$has_review_feedback" = "false" ]; then
        system_prompt="You are a Terraform code generator. Generate complete, production-quality Terraform code for AWS infrastructure. Return ONLY valid HCL code for main.tf, no explanations, no markdown formatting, no code blocks."
        user_prompt="Generate Terraform code for: $goal"
    else
        system_prompt="You are a Terraform code generator fixing code based on review feedback. Return ONLY valid HCL code for main.tf, no explanations, no markdown formatting, no code blocks."
        user_prompt="Generate Terraform code for: $goal

Review feedback to address:
$review_feedback"
    fi

    # Call OpenAI API
    api_response=$(curl -s https://api.openai.com/v1/chat/completions \
      -H "Authorization: Bearer $OPENAI_API_KEY" \
      -H "Content-Type: application/json" \
      -d @- <<EOF_JSON
{
  "model": "gpt-4o-mini",
  "messages": [
    {
      "role": "system",
      "content": $(echo "$system_prompt" | jq -Rs .)
    },
    {
      "role": "user",
      "content": $(echo "$user_prompt" | jq -Rs .)
    }
  ],
  "temperature": 0.7,
  "max_tokens": 2000
}
EOF_JSON
    ) || {
        echo "ERROR: OpenAI API call failed" >&2
        exit 1
    }

    # Check for API errors
    if echo "$api_response" | jq -e '.error' > /dev/null 2>&1; then
        error_msg=$(echo "$api_response" | jq -r '.error.message')
        echo "ERROR: OpenAI API error: $error_msg" >&2
        exit 1
    fi

    # Parse response
    generated_code=$(echo "$api_response" | jq -r '.choices[0].message.content') || {
        echo "ERROR: Failed to parse OpenAI response" >&2
        echo "Response: $api_response" >&2
        exit 1
    }

    # Validate non-empty
    if [ -z "$generated_code" ] || [ "$generated_code" = "null" ]; then
        echo "ERROR: Empty LLM response" >&2
        exit 1
    fi

    # Write generated code to main.tf
    echo "$generated_code" > main.tf

else
    echo "TerraformDrafter: Using mocked response (OPENAI_API_KEY not set)" >&2

    # First attempt: Always generate poorly formatted code to demonstrate review process
    # Rework attempt: Generate properly formatted code after receiving feedback
    if [ "$has_review_feedback" = "false" ]; then
        echo "TerraformDrafter: First attempt - generating code with formatting issues (demo)" >&2
        # MOCKED LLM RESPONSE: Deliberately poorly formatted code to trigger review failure
        cat > main.tf <<'EOF'
# Terraform module for S3 static website hosting (POORLY FORMATTED VERSION)
# Generated by Holt TerraformDrafter - intentionally bad formatting for demo

terraform {
required_version = ">= 1.0"
  required_providers {
aws = {
      source = "hashicorp/aws"
version = "~> 5.0"
}
  }
}

variable "bucket_name" {
description = "Name of the S3 bucket for static website hosting"
type = string
}

resource "aws_s3_bucket" "website" {
bucket=var.bucket_name
  tags={
Name=var.bucket_name
    Environment="demo"
}
}

output "bucket_name" {
  description="Name of the S3 bucket"
value=aws_s3_bucket.website.id
}
EOF
else
    echo "TerraformDrafter: Rework attempt - generating properly formatted code after feedback" >&2
    # MOCKED LLM RESPONSE: Properly formatted code in response to review feedback
    # In production, this would call OpenAI API with goal + feedback as context
    cat > main.tf <<'EOF'
# Terraform module for S3 static website hosting
# Generated by Holt TerraformDrafter

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

variable "bucket_name" {
  description = "Name of the S3 bucket for static website hosting"
  type        = string
}

variable "index_document" {
  description = "Index document for the website"
  type        = string
  default     = "index.html"
}

variable "error_document" {
  description = "Error document for the website"
  type        = string
  default     = "error.html"
}

resource "aws_s3_bucket" "website" {
  bucket = var.bucket_name

  tags = {
    Name        = var.bucket_name
    Environment = "demo"
    ManagedBy   = "Terraform"
  }
}

resource "aws_s3_bucket_website_configuration" "website" {
  bucket = aws_s3_bucket.website.id

  index_document {
    suffix = var.index_document
  }

  error_document {
    key = var.error_document
  }
}

resource "aws_s3_bucket_public_access_block" "website" {
  bucket = aws_s3_bucket.website.id

  block_public_acls       = false
  block_public_policy     = false
  ignore_public_acls      = false
  restrict_public_buckets = false
}

resource "aws_s3_bucket_policy" "website" {
  bucket = aws_s3_bucket.website.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid       = "PublicReadGetObject"
        Effect    = "Allow"
        Principal = "*"
        Action    = "s3:GetObject"
        Resource  = "${aws_s3_bucket.website.arn}/*"
      }
    ]
  })

  depends_on = [aws_s3_bucket_public_access_block.website]
}

output "website_endpoint" {
  description = "Website endpoint URL"
  value       = aws_s3_bucket_website_configuration.website.website_endpoint
}

output "bucket_name" {
  description = "Name of the S3 bucket"
  value       = aws_s3_bucket.website.id
}

output "bucket_arn" {
  description = "ARN of the S3 bucket"
  value       = aws_s3_bucket.website.arn
}
EOF
    fi
fi

# Commit the generated code
git add main.tf

# Check if there are changes to commit
if git diff --cached --quiet; then
    echo "TerraformDrafter: No changes to commit (file unchanged)" >&2
    commit_hash=$(git rev-parse HEAD)
else
    git commit -m "[holt-agent: TerraformDrafter] Generated Terraform code for S3 static website hosting

Goal: $goal" >&2
    commit_hash=$(git rev-parse HEAD)
fi

echo "TerraformDrafter: Committed Terraform code as $commit_hash" >&2

# Update the original branch to point to our new commit and checkout to it
# This preserves the branch for the next agent in the chain
if [ -n "$original_branch" ] && [ "$original_branch" != "HEAD" ]; then
    echo "TerraformDrafter: Updating branch $original_branch to point to new commit" >&2
    git branch -f "$original_branch" "$commit_hash" 2>/dev/null || true
    git checkout "$original_branch" --quiet 2>/dev/null || true
fi

# Output CodeCommit artefact with type "TerraformCode"
cat <<EOF
{
  "artefact_type": "TerraformCode",
  "artefact_payload": "$commit_hash",
  "summary": "Generated Terraform module for S3 static website hosting"
}
EOF
